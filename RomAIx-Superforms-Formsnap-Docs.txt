SUPERFORMS DOCS


Get started
I'm using


npm
and my validation library is


Zod
npm i -D sveltekit-superforms zod
Select your environment above and run the install command in your project folder.


If you’re starting from scratch, create a new SvelteKit project:


npm create svelte@latest
Alternatively, open the Stackblitz project to follow along in the browser and copy the code.


Creating a Superform


This tutorial will create a Superform containing a name and an email address, ready to be expanded with more form data.


Creating a validation schema


The main thing required to create a Superform is a validation schema, representing the form data for a single form.


import { z } from 'zod';


const schema = z.object({
  name: z.string().default('Hello world!'),
  email: z.string().email()
});
Schema caching


The schema should be defined outside the load function, in this case on the top level of the module. This is very important to make caching work. The adapter is memoized (cached) with its arguments, so they must be kept in memory. Therefore, define the schema, its options and eventual defaults on the top level of a module, so they always refer to the same object.


Initializing the form in the load function


To initialize the form, the schema should be used in a load function with the superValidate function:


src/routes/+page.server.ts


import { superValidate } from 'sveltekit-superforms';
import { zod } from 'sveltekit-superforms/adapters';
import { z } from 'zod';


// Define outside the load function so the adapter can be cached
const schema = z.object({
  name: z.string().default('Hello world!'),
  email: z.string().email()
});


export const load = (async () => {
  const form = await superValidate(zod(schema));


  // Always return { form } in load functions
  return { form };
});
The Superform server API is called superValidate. You can call it in two ways in the load function:


Empty form


If you want the form to be initially empty, just pass the adapter as in the example above, and the form will be filled with default values based on the schema. For example, a string field results in an empty string, unless you have set a default.


Populate form from database


If you want to populate the form, you can send data to superValidate as the first parameter, adapter second, like this:


export const load = async ({ params }) => {
  const user = db.users.findUnique({
    where: { id: params.id }
  });


  if (!user) error(404, 'Not found');


  const form = await superValidate(user, zod(schema));


  // Always return { form } in load functions
  return { form };
};
As long as the data partially matches the schema, you can pass it directly to superValidate. This is useful for backend interfaces, where the form should usually be populated based on a url like /users/123.


Errors will be automatically displayed when the form is populated, but not when empty. You can modify this behavior with an option.


Important note about return values


Unless you call the SvelteKit redirect or error functions, you should always return the form object to the client, either directly or through a helper function. The name of the variable doesn’t matter; you can call it { loginForm } or anything else, but it needs to be returned like this in all code paths that returns, both in load functions and form actions.


Displaying the form


The superValidate function returns the data required to instantiate a form on the client, now available in +page.svelte as data.form, as we did return { form }. There, we’ll use the client part of the API:


src/routes/+page.svelte


<script lang="ts">
  import { superForm } from 'sveltekit-superforms';


  export let data;


  // Client API:
  const { form } = superForm(data.form);
</script>


<form method="POST">
  <label for="name">Name</label>
  <input type="text" name="name" bind:value={$form.name} />


  <label for="email">E-mail</label>
  <input type="email" name="email" bind:value={$form.email} />


  <div><button>Submit</button></div>
</form>
The superForm function is used to create a form on the client, and bind:value is used to create a two-way binding between the form data and the input fields.


Two notes: There should be only one superForm instance per form - its methods cannot be used in multiple forms. And don’t forget the name attribute on the input fields! Unless you are using nested data, they are required.


This is what the form should look like now:


Name 
Hello world!
E-mail 
Submit
Debugging


We can see that the form has been populated with the default values. But let’s add the debugging component SuperDebug to gain more insight:


src/routes/+page.svelte


<script lang="ts">
  import SuperDebug from 'sveltekit-superforms';
</script>


<SuperDebug data={$form} />
This should be displayed:


200
{
  name: "Hello world!",
  email: ""
}
When editing the form fields (try in the form above), the data is automatically updated. The component also displays the current page status in the right corner.


Posting data


In the form actions, defined in +page.server.ts, we’ll use the superValidate function again, but now it should handle FormData. This can be done in several ways:


Use the request parameter (which contains FormData)
Use the event object (which contains the request)
Use FormData directly, if you need to access it before calling superValidate.
The most common is to use request:


src/routes/+page.server.ts


import { fail } from '@sveltejs/kit';


export const actions = {
  default: async ({ request }) => {
    const form = await superValidate(request, zod(schema));
    console.log(form);


    if (!form.valid) {
      // Again, return { form } and things will just work.
      return fail(400, { form });
    }


    // TODO: Do something with the validated form.data


    // Yep, return { form } here too
    return { form };
  }
};
Now we can post the form back to the server. Submit the form, and see what’s happening on the server:


{
  id: 'a3g9kke',
  valid: false,
  posted: true,
  data: { name: 'Hello world!', email: '' },
  errors: { email: [ 'Invalid email' ] },
}
This is the validation object returned from superValidate, containing the data needed to update the form:


Property        Purpose
id        Id for the schema, to handle multiple forms on the same page.
valid        Tells you whether the validation succeeded or not. Used on the server and in events.
posted        Tells you if the data was posted (in a form action) or not (in a load function).
data        The posted data, which should be returned to the client using fail if not valid.
errors        An object with all validation errors, in a structure reflecting the data.
message        (optional) Can be set as a status message.
There are some other properties as well, that are only being sent in the load function:


Property        Purpose
constraints        An object with HTML validation constraints, that can be spread on input fields.
shape        Used internally in error handling.
You can modify any of these, and they will be updated on the client when you return { form }. There are a couple of helper functions for making this more convenient, like message and setError.


Displaying errors


Now we know that validation has failed and there are errors being sent to the client. We display these by adding properties to the destructuring assignment of superForm:


src/routes/+page.svelte


<script lang="ts">
  const { form, errors, constraints } = superForm(data.form);
  //            ^^^^^^  ^^^^^^^^^^^
</script>


<form method="POST">
  <label for="name">Name</label>
  <input
    type="text"
    name="name"
    aria-invalid={$errors.name ? 'true' : undefined}
    bind:value={$form.name}
    {...$constraints.name} 
  />
  {#if $errors.name}<span class="invalid">{$errors.name}</span>{/if}


  <label for="email">E-mail</label>
  <input
    type="email"
    name="email"
    aria-invalid={$errors.email ? 'true' : undefined}
    bind:value={$form.email}
    {...$constraints.email} 
  />
  {#if $errors.email}<span class="invalid">{$errors.email}</span>{/if}


  <div><button>Submit</button></div>
</form>


<style>
  .invalid {
    color: red;
  }
</style>
As you see, by including errors, we can display errors where it’s appropriate, and through constraints (already provided by the load function), we get browser validation even without JavaScript enabled. The aria-invalid attribute is used to automatically focus on the first error field.


We now have a fully working form, with convenient handling of data and validation both on the client and server!


There are no hidden DOM manipulations or other secrets; it’s just HTML attributes and Svelte stores. No JavaScript is needed for the basics.


Adding progressive enhancement


As a last step, let’s add progressive enhancement, so the JS users will have a better experience. It’s also required to use for example client-side validation and events, and of course to avoid reloading the page when the form is posted.


This is simply done with enhance, returned from superForm:


<script lang="ts">
  const { form, errors, constraints, enhance } = superForm(data.form);
  //                                 ^^^^^^^
</script>


<!-- Add to the form element: -->
<form method="POST" use:enhance>
Now the page won’t fully reload when submitting, and we unlock lots of client-side features like timers for loading spinners, auto error focus, tainted fields, etc, that you can read about under the Concepts section in the navigation.


The use:enhance action takes no arguments; instead, events are used to hook into the SvelteKit use:enhance parameters and more. Check out the events page for details.


Next steps


This concludes the tutorial! To learn the details, keep reading under the Concepts section in the navigation. Status messages are very common to add, for example. Also, if you plan to use nested data (objects and arrays within the schema), read the nested data page carefully. The same goes for having multiple forms on the same page.


When you’re ready for something more advanced, check out the CRUD tutorial, which shows how to make a fully working backend in about 150 lines of code.


API reference
Throughout the reference, the type T represents the type of the validation schema, extending Record<string, unknown>. For example, in a form with name and email, name being optional:


type T = {
  name?: string | undefined,
  email: string
};
The Nested<T, R> type replaces all primitive values of T with R, and removes any optional modifier. In the above example:


type Nested<T, string[]> = {
  name: string[],
  email: string[]
};
The type M represents the status message type, default any.


type M = any;
A ValidationAdapter<T, In> and ClientValidationAdapter<T, In> are the adapters used to wrap the schema, based on the selected validation library. In is the input type of the schema, as transformations and pipes can make it differ from T, but usually they are the same. Example:


import type { Infer, InferIn } from 'sveltekit-superforms';
import { zod, zodClient } from 'sveltekit-superforms/adapters';
import { z } from 'zod';


const schema = z.object({
  name: z.string().min(3)
})


// Type is now ValidationAdapter<Infer<typeof schema>, InferIn<typeof schema>>
// Which is the same as ValidationAdapter<{name: string}, {name: string}>
const adapter = zod(schema);
Server API


import {
  superValidate,
  actionResult,
  defaultValues,
  message,
  setError
} from 'sveltekit-superforms';
superValidate(adapter | data, adapter? | options?, options?)


If you want the form to be initially empty, you can pass the adapter as the first parameter:


superValidate<T, M = any, In = T>(
  adapter: ValidationAdapter<T, In>,
  options?: SuperValidateOptions
): Promise<SuperValidated<T, M, In>>
If you want to populate the form, for example, from a database, URL parameters in the load function, or FormData in the form actions, send the data as the first parameter and the adapter second:


superValidate<T, M = any, In = T>(
  data:
    | RequestEvent
    | Request
    | FormData
    | URL
    | URLSearchParams
    | Partial<In>
    | null
    | undefined,
  adapter: ValidationAdapter<T, In>,
  options?: SuperValidateOptions
): Promise<SuperValidated<T, M, In>>
superValidate options


SuperValidateOptions = {
  errors?: boolean;           // Add or remove errors from output (valid status is always preserved)
  id?: string;                // Form id, for multiple forms support. Set automatically by default
  preprocessed?: (keyof T)[]; // Bypass superValidate data coercion for posted fields in this array
  defaults?: T;               // Override default values from the schema
  jsonSchema?: JSONSchema;    // Override JSON schema from the adapter
  strict?: boolean;           // If true, validate exactly the posted data, no defaults added
  allowFiles?: boolean;       // If false, set all posted File objects to undefined
}
See the page about multiple forms for information about when to use id.


superValidate return type


SuperValidated<T, M = any, In = T> = {
  id: string;
  valid: boolean;
  posted: boolean;
  data: T;
  errors: Nested<T, string[] | undefined>;
  constraints?: Nested<T, InputConstraints | undefined>;
  message?: M;
};
If data is empty, a SuperValidated object with default values for the schema is returned:


{
  id: string;
  valid: false;
  posted: false;
  errors: options.errors ? Nested<T, string[] | undefined> : {};
  data: T;
  constraints: Nested<T, InputConstraints>;
}
See this page for a list of default schema values.


Input constraints


/**
 * HTML input constraints returned from superValidate
 * Properties are mapped from the schema:
 */
InputConstraints = Partial<{
  required: boolean; // Not nullable or optional
  pattern: string; // The *first* string validator with RegExp pattern
  min: number | string; // number or ISO date string depending on type
  max: number | string; // number or ISO date string depending on type
  step: number | 'any'; // number validator with step constraint
  minlength: number; // string validator
  maxlength: number; // string validator
}>;
setError(form, field, error, options?)


setError(
  form: SuperValidated<T, M, In>,
  field: '' | FormPathLeaves<T>,
  error: string | string[],
  options?: { overwrite = false, status : ErrorStatus = 400 }
) : ActionFailure<{form: SuperValidated<T, M, In>}>
For setting errors on the form after validation. It returns a fail(status, { form }) so it can be returned immediately, or more errors can be added by calling it multiple times before returning.


Use the overwrite option to remove all previously set errors for the field, and status to set a different status than the default 400 (which must be in the range 400-599).


To set a form-level error, the field argument can be skipped, or set to an empty string.
To set an array-level error, append ._errors to the field parameter, like "tags._errors".
message(form, message, options?)


message(
  form: SuperValidated<T, M, In>,
  message: M,
  options?: { status? : NumericRange<400, 599> }
) : { form: SuperValidated<T, M, In> } | ActionFailure<{form: SuperValidated<T, M, In>}>
message is a convenience method for setting form.message, best explained by an example:


import { message, superValidate } from 'sveltekit-superforms/server';


export const actions = {
  default: async (event) => {
    const form = await superValidate<typeof schema, string>(event, schema);


    if (!form.valid) {
      // Will return fail(400, { form }) since form isn't valid
      return message(form, 'Invalid form');
    }


    if (form.data.email.includes('spam')) {
      // Will return fail and set form.valid = false, since status is >= 400
      return message(form, 'No spam please', {
        status: 403
      });
    }


    // Returns { form }
    return message(form, 'Valid form!');
  }
};
Note that the status option must be in the range 400-599.


defaultValues(schema)


Returns the default values for a schema, either the Superforms defaults or the ones you set on the schema yourself.


import { defaultValues } from 'sveltekit-superforms';
import { zod } from 'sveltekit-superforms/adapters';
import { z } from 'zod';


const schema = z.object({
  name: z.string().min(2),
  tags: z.string().min(1).array().default(['a', 'b'])
});


// Returns { name: '', tags: ['a', 'b'] }
const defaults = defaultValues(zod(schema));
This corresponds to the form.data returned from const form = await superValidate(zod(schema)).


actionResult(type, data?, options? | status?)


When using an endpoint (a +server.ts file) instead of form actions, you must return an ActionResult to a form that has use:enhance applied. Anything else won’t work, not even throwing a redirect, since superForm expects an ActionResult.


The actionResult function helps you construct one in a Response object, so you can return a validation object from your API/endpoints.


import { actionResult } from 'sveltekit-superforms';


actionResult('success', { form }, 200);
actionResult('failure', { form }, 400);
actionResult('redirect', '/', 303);
actionResult('error', 'Error message', 500);
The default status codes for each result type are shown, so you don’t need to include them if they’re the same.


Additionally, the redirect version can send a flash message as a third parameter, in case you’re using flash messages. It can also set options for the flash cookie that’s being set.


actionResult('redirect', '/', {
  message: { type: 'success', text: 'Posted successfully!' },
  cookieOptions: { sameSite: 'lax' }
});
Login request example


src/routes/login/+server.ts


import { actionResult, superValidate } from '$lib/server';
import { zod } from 'sveltekit-superforms/adapters';
import { z } from 'zod';


const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(5)
});


export const POST = async ({ request }) => {
  const form = await superValidate(request, zod(loginSchema));
  if (!form.valid) return actionResult('failure', { form });


  // Verify login here //


  return actionResult('success', { form });
};
Client API


import { 
  superForm, 
  defaults 
} from 'sveltekit-superforms';
superForm(form, options?)


superForm<T, M = any>(
  form: SuperValidated<T, M, In> | null | undefined,
  options?: FormOptions<T, M, In>
) : SuperForm<T, M>
superForm options


type FormOptions<T, M, In> = Partial<{
  // Basics
  id: string;
  applyAction: boolean;
  invalidateAll: boolean | 'force';
  resetForm: boolean | (() => boolean);
  taintedMessage: boolean | string | (() => Promise<boolean>);
  dataType: 'form' | 'json';
  multipleSubmits: 'prevent' | 'allow' | 'abort';
  SPA: true | { failStatus?: number };


  // Error handling
  scrollToError: 'auto' | 'smooth' | 'off' | boolean | ScrollIntoViewOptions;
  autoFocusOnError: 'detect' | boolean;
  errorSelector: string;
  selectErrorText: boolean;
  stickyNavbar: string;


  // Events
  onSubmit: (
    submit: Parameters<SubmitFunction> & { 
      jsonData: (data: Record<string, unknown>) => void,
      validators: (validators: ValidationAdapter<Partial<T>, Record<string, unknown>> | false) => void
    }
  ) => MaybePromise<unknown | void>;
  onResult: (event: {
    result: ActionResult;
    formEl: HTMLFormElement;
    cancel: () => void;
  }) => MaybePromise<unknown | void>;
  onUpdate: (event: {
    form: SuperValidated<T, M, In>;
    formEl: HTMLFormElement;
    cancel: () => void;
  }) => MaybePromise<unknown | void>;
  onUpdated: (event: {
    form: Readonly<SuperValidated<T, M, In>>;
  }) => MaybePromise<unknown | void>;
  onChange: (event: ChangeEvent) => void;
  onError:
    | 'apply'
    | ((event: {
        result: {
          type: 'error';
          status?: number;
          error: App.Error;
        };
        message: Writable<SuperValidated<T, M, In>['message']>;
      }) => MaybePromise<unknown | void>);


  // Client-side validation
        validators:
                | ClientValidationAdapter<Partial<T>, Record<string, unknown>>
                | ValidationAdapter<Partial<T>, Record<string, unknown>>
                | false
                | 'clear';
  validationMethod: 'auto' | 'oninput' | 'onblur' | 'onsubmit';
  clearOnSubmit: 'errors-and-message' | 'message' | 'errors' | 'none';
  delayMs: number;
  timeoutMs: number;


  // Special flash message integration (not usually required)
  syncFlashMessage?: boolean;
  flashMessage: {
    module: import * as flashModule from 'sveltekit-flash-message/client';
    onError?: (event: {
      result: {
        type: 'error';
        status?: number;
        error: App.Error;
      };
      message: Writable<App.PageData['flash']>;
    }) => MaybePromise<unknown | void>;
    cookiePath?: string;
    cookieName?: string;
  };


  // Disable warnings
  warnings: {
    duplicateId?: boolean;
  };
}>;


type ChangeEvent<T> =
{
  path: FormPath<T>;
  paths: FormPath<T>[];
  formElement: HTMLFormElement;
  target: Element;
  set: <Path extends FormPath<T>>(
    path: Path,
    value: FormPathType<T, Path>,
    options?: { taint?: boolean | 'untaint' | 'untaint-form' }
  ) => void;
  get: <Path extends FormPath<T>>(path: Path) => FormPathType<T, Path>;
} | {
  target: undefined;
  paths: FormPath<T>[];
  set: <Path extends FormPath<T>>(
    path: Path,
    value: FormPathType<T, Path>,
    options?: { taint?: boolean | 'untaint' | 'untaint-form' }
  ) => void;
  get: <Path extends FormPath<T>>(path: Path) => FormPathType<T, Path>;
};
See SubmitFunction for details about the onSubmit arguments, and ActionResult for onResult.


superForm return type


SuperForm<T, M = any, In = T> = {
  form: {
    subscribe: (data: T) => void
    set: (value: T, options?: { taint?: boolean | 'untaint' | 'untaint-form' }) => void
    update: (updater: (T) => T, options?: { taint?: boolean | 'untaint' | 'untaint-form' }) => void
  };
  errors: Writable<Nested<T, string[] | undefined>>;
  constraints: Writable<Nested<T, InputConstraints | undefined>>;
  message: Writable<M | undefined>;
  tainted: Writable<Nested<T, boolean | undefined> | undefined>;


  submitting: Readable<boolean>;
  delayed: Readable<boolean>;
  timeout: Readable<boolean>;
  posted: Readable<boolean>;


  formId: Writable<string>;
  allErrors: Readable<{ path: string; messages: string[] }[]>;


  options: FormOptions<T, M, In>;


  enhance: (el: HTMLFormElement, events?: {
    onSubmit, onResult, onError, onUpdate, onUpdated
  }) => ReturnType<typeof $app/forms/enhance>;


  reset: (options?: {
    keepMessage?: boolean;
    data?: Partial<T>;
    id?: string;
  }) => void;


  submit: (submitter?: HTMLElement | null) => void;


  capture: () => SuperFormSnapshot<T, M>;
  restore: (snapshot: SuperFormSnapshot<T, M>) => void;


  validateForm: (opts?: {
    update?: boolean;
    schema?: ValidationAdapter<Partial<T>>;
    focusOnError?: boolean;
  }) => Promise<SuperValidated<T, M, In>>;


  validate: (path: FormPathLeaves<T>, opts?: {
    value: FormPathType<FormPathLeaves<T>>;
    update: boolean | 'errors' | 'value';
    taint: boolean | 'untaint' | 'untaint-form';
    errors: string | string[];
  }) => Promise<string[] | undefined>;
};
defaults


The defaults function can be useful on the client in Svelte components and SPA mode, since components cannot have top-level await.


defaults<T, M = any>(
  data:
    | Partial<T>
    | null
    | undefined,
  schema: ClientValidationAdapter<T>,
  options?: SuperValidateOptions
): SuperValidated<T, M, In>
Proxy objects


import {
  // The primitives return a Writable<string>:
  booleanProxy,
  dateProxy,
  intProxy,
  numberProxy,
  stringProxy,
  // The type of the other three depends on the field:
  formFieldProxy,
  arrayProxy,
  fieldProxy      
} from 'sveltekit-superforms';
A proxy handles bi-directional updates and data transformation of a corresponding form field. Updates in either the proxy or data it points to, will reflect in the other.


intProxy(form, fieldName, options?)


Creates a string store for an integer field in the schema. It’s rarely needed as Svelte handles this automatically with bind:value.


import { superForm, intProxy } from 'sveltekit-superforms';
export let data;


const { form } = superForm(data.form);
const proxy = intProxy(form, 'field', { options });
Options:


{ 
  empty?: 'null' | 'undefined';
  emptyIfZero?: boolean = true;
  zeroIfEmpty?: boolean = false;
  taint?: TaintOption;
}
Use the empty option to set the field to null or undefined if the value is falsy, Which includes the number zero, unless emptyIfZero is set to false. The reverse, zeroIfEmpty, sets the field to zero if the string value of the proxy is empty.


numberProxy(form, fieldName, options?)


Creates a string store for a number field in the schema. It’s rarely needed as Svelte handles this automatically with bind:value.


import { superForm, numberProxy } from 'sveltekit-superforms';
export let data;


const { form } = superForm(data.form);
const proxy = numberProxy(form, 'field', { options });
Options:


{ 
  empty?: 'null' | 'undefined';
  emptyIfZero?: boolean = true;
  delimiter?: '.' | ',';
}
Use the empty option to set the field to null or undefined if the value is falsy. (Which includes the number zero, unless emptyIfZero is set to false.)


booleanProxy(form, fieldName, options?)


Creates a string store for a boolean schema field. The option can be used to change what string value should represent true. An empty string always represents false.


import { superForm, booleanProxy } from 'sveltekit-superforms';
export let data;


const { form } = superForm(data.form);
const proxy = booleanProxy(form, 'field', { options });
Options:


{
  trueStringValue = 'true';
}
dateProxy(form, fieldName, options?)


Creates a string store for a Date schema field. The option can be used to change the proxied string format of the date.


import { superForm, dateProxy } from 'sveltekit-superforms';
export let data;


const { form } = superForm(data.form);
const proxy = dateProxy(form, 'field', { options });
Options:


{
  format:
    // Extract the part of the date as a substring:
    | 'date' | 'datetime' | 'time'
    // Convert the date to UTC:
    | 'date-utc' | 'datetime-utc' | 'time-utc'
    // Convert the date to local time:
    | 'date-local' | 'datetime-local' | 'time-local'
    // The default ISODateString:
    | 'iso' = 'iso';
  empty?: 'null' | 'undefined'
}
stringProxy(form, fieldName, options)


Creates a string store for a string schema field. It may look redundant, but the option can be useful if you need to convert an empty string to null or undefined.


import { superForm, stringProxy } from 'sveltekit-superforms';
export let data;


const { form } = superForm(data.form);
const proxy = stringProxy(form, 'field', { options });
Options:


{
  empty: 'null' | 'undefined';
}
formFieldProxy(superForm, fieldName, options)


Proxies a form field, returning stores similar to superForm but for a single field. For arrays in the schema, see below for how to create an arrayProxy.


The whole object returned from superForm is required here, not just the $form store.


<script lang="ts">
  import { superForm, formFieldProxy } from 'sveltekit-superforms';


  export let data;


  const theForm = superForm(data.form); // The whole superForm object is required
  const { form } = theForm; // Deconstruct as usual here


  const { path, value, errors, constraints, tainted } = formFieldProxy(theForm, 'name');
</script>
Options:


{
  taint: boolean | 'untaint' | 'untaint-all' = true;
}
The option can be used to prevent tainting the form when modifying the proxy.


For more details about formFieldProxy, see the components page.


arrayProxy(superForm, fieldName, options)


Proxies an array in a form, returning stores similar to superForm but for the array.


The whole object returned from superForm is required here, not just the $form store.


<script lang="ts">
  import { superForm, arrayProxy } from 'sveltekit-superforms';


  export let data;


  const theForm = superForm(data.form); // The whole superForm object is required
  const { form } = theForm; // Deconstruct as usual here


  const { path, values, errors, fieldErrors } = arrayProxy(theForm, 'tags');
</script>
errors displays errors for the array itself, for example if the number of items are too few.
fieldErrors is an array that lists errors for the contents of the array.
Options:


{
  taint: boolean | 'untaint' | 'untaint-all' = true;
}
The option can be used to prevent tainting the form when modifying the proxy.


An example of how to use arrayProxy in a component is available on Stackblitz.


fieldProxy(object, fieldName)


Proxies field access in any object, usually in $form, but in that case formFieldProxy and arrayProxy are more convenient.


<script lang="ts">
  import { superForm, fieldProxy } from 'sveltekit-superforms';
  export let data;


  const { form } = superForm(data.form);


  // Proxy any field in an object
  const nameProxy = fieldProxy(form, 'name');
</script>
Proxy example


Given the following schema:


const schema = z.object({
  date: z.date()
});
A proxy for a HTML date field can be used like this:


<script lang="ts">
  import { superForm, dateProxy } from 'sveltekit-superforms';
  import type { PageData } from './$types.js';


  export let data: PageData;


  const { form, enhance } = superForm(data.form);
  const date = dateProxy(form, 'date', { format: 'date', empty: 'undefined' });
</script>


<input name="date" type="date" bind:value={$date} />
Components


SuperDebug


SuperDebug is a must-have debugging component that gives you colorized and nicely formatted output for any data structure, usually $form.


More information and usage examples can be found on the SuperDebug page.






































Client-side validation
There are two client-side validation options with Superforms:


The built-in browser validation, which doesn’t require JavaScript to be enabled in the browser.
Using a validation schema, usually the same one as on the server. Requires JavaScript and use:enhance.
Built-in browser validation


There is a web standard for form input, which doesn’t require JavaScript and is virtually effortless to use with Superforms:


constraints


To use the built-in browser validation, just spread the $constraints store for a schema field on its input field:


<script lang="ts">
  export let data;
  const { form, constraints } = superForm(data.form);
</script>


<input
  name="email"
  type="email"
  bind:value={$form.email}
  {...$constraints.email} />
The constraints is an object with validation properties mapped from the schema:


{
  pattern?: string;      // The *first* string validator with a RegExp pattern
  step?: number | 'any'; // number with a step validator
  minlength?: number;    // string with a minimum length
  maxlength?: number;    // string with a maximum length
  min?: number | string; // number if number validator, ISO date string if date validator
  max?: number | string; // number if number validator, ISO date string if date validator
  required?: true;       // true if not nullable, nullish or optional
}
Special input formats


For some input types, a certain format is required. For example with date fields, both the underlying data and the constraint needs to be in yyyy-mm-dd format, which can be handled by using a proxy and adding attributes after the constraints spread, in which case they will take precedence:


<input
  name="date"
  type="date"
  aria-invalid={$errors.date ? 'true' : undefined}
  bind:value={$proxyDate}
  {...$constraints.date}
  min={$constraints.date?.min?.toString().slice(0, 10)} 
/>
Check the validation attributes and their valid values at MDN.


Using a validation schema


The built-in browser validation can be a bit constrained; for example, you can’t easily control the position and appearance of the error messages. Instead (or supplementary), you can use a validation schema and customize the validation with a number of options, so the form errors will be displayed in real-time.


As with most client-side functionality, use:enhance is required for real-time validation.


const { form, enhance, constraints, validate, validateForm } = superForm(data.form, {
  validators: ClientValidationAdapter<S> | 'clear' | false,
  validationMethod: 'auto' | 'oninput' | 'onblur' | 'submit-only' = 'auto',
  customValidity: boolean = false
})
validators


validators: ClientValidationAdapter<S> | 'clear' | false
Setting the validators option to an adapter with the same schema as on the server, is the most convenient and recommended way. Just put the schema in a shared directory, $lib/schemas for example, and import it on the client as well as on the server.


Adding a adapter on the client will increase the client bundle size a bit, since the validation library now has to be imported there too. But the client-side adapter is optimized to be as small as possible, so it shouldn’t be too much of an issue. To use it, append Client to the adapter import, for example:


import { valibotClient } from 'sveltekit-superforms/adapters';
import { schema } from './schema.js';


const { form, errors, enhance } = superForm(data.form, {
  validators: valibotClient(schema)
});
This works only with the same schema as the one used on the server. If you need to switch schemas on the client, you need the full adapter (for example zod instead of zodClient).


As a super-simple alternative to an adapter, you can also set the option to 'clear', to remove errors for a field as soon as it’s modified.


Switching schemas


You can even switch schemas dynamically, with the options object. options.validators accepts a partial validator, which can be very useful for multi-step forms:


import { valibot } from 'sveltekit-superforms/adapters';
import { schema, partialSchema } from './schema.js';


const { form, errors, enhance, options } = superForm(data.form, {
  // Validate the first step of the form
  validators: valibot(partialSchema)
});


// When moving to the last step of the form
options.validators = valibot(schema)
As mentioned, you need the full adapter to switch schemas dynamically. An exception will be thrown if a client adapter is detected different from the initial validators option.


validationMethod


validationMethod: 'auto' | 'oninput' | 'onblur' | 'onsubmit',
The validation is triggered when a value is changed, not just when focusing on, or tabbing through a field. The default validation method is based on the “reward early, validate late” pattern, a researched way of validating input data that makes for a high user satisfaction:


If entering data in a field that has or previously had errors, validate on input
Otherwise, validate on blur.
But you can instead use the oninput or onblur settings to always validate on one of these respective events, or onsubmit to validate only on submit.


Be aware that the whole schema will be validated, not just the modified field, because errors can be added to any field in the schema during validation with Zod’s refine or similar, so the whole schema must be validated to know the final result.


customValidity


This option uses the browser built-in tooltip to display validation errors, so neither $errors nor $constraints are required on the form. See the error handling page for details and an example.


validate


The validate function, deconstructed from superForm, gives you complete control over the validation process for specific fields. Examples of how to use it:


const { form, enhance, validate } = superForm(data.form, {
  validators: zod(schema) // Required option for validate to work
});


// Simplest case, validate what's in the field right now
validate('name');


// Validate without updating, for error checking
const nameErrors = await validate('name', { update: false });


// Validate and update field with a custom value
validate('name', { value: 'Test' });


// Validate a custom value, update errors only
validate('name', { value: 'Test', update: 'errors' });


// Validate and update nested data, and also taint the field
validate('tags[1].name', { value: 'Test', taint: true });
validateForm


Similar to validate, validateForm lets you validate the whole form and return a SuperValidated result:


const { form, enhance, validateForm } = superForm(data.form, {
  validators: zod(schema) // Required option for validate to work
});


const result = await validateForm();


if (result.valid) {
  // ...
}


// You can use the update option to trigger a client-side validation
await validateForm({ update: true });


// Or the schema option to validate the form partially
const result2 = await validateForm({ schema: zod(partialSchema) });
Asynchronous validation and debouncing


The validation is asynchronous, but a slow validator will delay the final result, so for a server round-trip validation like checking if a username is available, you might want to exclude that field from the schema and handle it manually, with on:input and a package like throttle-debounce.


Errors can also be set manually by updating the $errors store:


// Needs to be a string[]
$errors.username = ['Username is already taken.'];
Test it out


This example demonstrates how validators are used to check if tags are of the correct length.


Set a tag name to blank and see that no errors show up until you move focus outside the field (blur). When you go back and correct the mistake, the error is removed as soon as you enter more than one character (input).




Toggle SuperDebug


{
  tags: [
    "a",
    "svelte"
  ]
}


Tags
a
 
svelte
 
Add new tag...
Submit
Next


Error handling
By deconstructing errors from superForm, you’ll get an object with form errors that you can display where it’s appropriate:


<script lang="ts">
  const { form, errors } = superForm(data.form);
</script>


<form method="POST">
  <label for="name">Name</label>
  <input
    name="name"
    aria-invalid={$errors.name ? 'true' : undefined}
    bind:value={$form.name}
  />
  {#if $errors.name}<span class="invalid">{$errors.name}</span>{/if}


  <div><button>Submit</button></div>
</form>
The aria-invalid attribute is used to automatically focus on the first error field; see the errorSelector option further below.


setError


Most errors will be set automatically when the data is validated, but you may want to add errors after determining that the data is valid. This is easily done with the setError helper function.


import { setError, superValidate } from 'sveltekit-superforms';
import { zod } from 'sveltekit-superforms/adapters';


export const actions = {
  default: async ({ request }) => {
    const form = await superValidate(request, zod(schema));


    if (!form.valid) {
      return fail(400, { form });
    }


    if (db.users.find({ where: { email: form.data.email } })) {
      return setError(form, 'email', 'E-mail already exists.');
    }


    return { form };
  }
};
setError returns a fail(400, { form }) so it can be returned immediately, or more errors can be added by calling it multiple times before returning. Check the API for additional options.


If you’re using nested data, a string path is used to specify where in the data structure the error is:


setError(form, `post.tags[${i}].name`, 'Invalid tag name.');
Errors added with setError will be removed when a schema is used in client-side validation and the first validation occurs (such as modifying a field).


Server errors


If something goes wrong beyond validation, instead of return fail(400, { form }), you can also call the SvelteKit error function, which can then be handled with the onError event, or, if the custom use:enhance doesn’t exist on the form, the nearest +error.svelte page will be rendered.


To avoid data loss even for non-JavaScript users, returning a status message instead of throwing an error is recommended.


Initial form errors


The default data in an empty form is usually invalid, but displaying lots of errors upon page load doesn’t look good. Superforms handles it like this:


If no data was posted or sent to superValidate, no errors will be returned unless the errors option in superValidate is true. This is what happens in load functions when the only the schema is sent to superValidate:


export const load = async () => {
  // No errors set, since no data is sent to superValidate
  const form = await superValidate(zod(schema));


  // No data, but errors can still be added with an option
  const form2 = await superValidate(zod(schema), { errors: true });
};
If data was sent to superValidate, either posted or populated with data, errors will be returned unless the errors option is false.


export const load = async () => {
  const initialData = { test: 123 };


  // Form is populated, so errors will be set if validation fails
  const form = await superValidate(initialData, zod(schema));


  // No errors will be set, even if validation fails
  const form2 = await superValidate(initialData, zod(schema), { errors: false });
};


export const actions = {
  default: async ({ request }) => {
    // Data is posted, so form.errors will be populated
    const form = await superValidate(request, zod(schema));


    // Unless we turn them off (which is rare in form actions)
    const form2 = await superValidate(request, zod(schema), { errors: false });
  }
};
The errors option does not affect the valid property of the SuperValidated object, which always indicates whether validation succeeded or not.


Usage (client)


As said, errors are available in the $errors store. It gives you high flexibility, since you can place error messages anywhere on the page.


In larger forms, the submit button may be far away from the error, so it’s nice to show the user where the first error is. There are a couple of options for that:


const { form, enhance, errors, allErrors } = superForm(data.form, {
  errorSelector: string | undefined = '[aria-invalid="true"],[data-invalid]',
  scrollToError: 'auto' | 'smooth' | 'off' | boolean | ScrollIntoViewOptions = 'smooth',
  autoFocusOnError: boolean | 'detect' = 'detect',
  stickyNavbar: string | undefined = undefined,
  customValidity: boolean = false
})
errorSelector


This is the CSS selector used to locate the invalid input fields after form submission. The default is [aria-invalid="true"],[data-invalid], and the first one found in the form will be scrolled to and focused on, depending on the other settings. You usually set it on the input fields as such:


<input
  type="email"
  name="email"
  bind:value={$form.email}
  aria-invalid={$errors.email ? 'true' : undefined} />
scrollToError


The scrollToError option determines how to scroll to the first error message in the form. smooth and auto are values from Window.scroll. If the non-string options are used, Element.scrollIntoView will be called with the option. This is mostly used with nested scrollbars, in which case Window.scroll won’t work.


autoFocusOnError


When autoFocusOnError is set to its default value detect, it checks if the user is on a mobile device; if not, it will automatically focus on the first error input field. It’s prevented on mobile devices since focusing will open the on-screen keyboard, causing the viewport to shift, which could hide the validation error.


stickyNavbar


If you have a sticky navbar, set its CSS selector here and it won’t hide any errors due to its height and z-index.


customValidity


This option uses the Constraint Validation API to display validation errors. By enabling this, with use:enhance added to the form, instead of the standard messages, the Zod validation errors will now be displayed in the browser validation tooltip. Submit the following form without entering any data to see it in action:


Name 
E-mail 
Submit
Since validation is handled by Superforms, there is no need for spreading $constraints on the field. But the biggest win is that there is no need to display $errors, making for a minimal html:


const { form, enhance } = superForm(data.form, {
  customValidity: true,
  // Not required, but will use client-side validation for real-time error display:
  validators: schema
});
<input type="text" name="name" bind:value={$form.name} />
The name attribute is required on the input fields. If you want to exclude a field from displaying the tooltip, add a data-no-custom-validity attribute to it.


Just be aware that since use:enhance is needed, customValidity requires JavaScript to be enabled, unlike browser constraints.


Form-level and array errors


It’s possible to set form-level errors by refining the schema, which works better together with client-side validation, as errors added with setError won’t persist longer than the first validation of the schema on the client.


const refined = z.object({
  tags: z.string().array().max(3)
  password: z.string().min(8),
  confirm: z.string().min(8)
})
.refine((data) => data.password == data.confirm, "Passwords didn't match.");
These can be accessed on the client through $errors?._errors. The same goes for array errors, which in the above case can be accessed through $errors.tags?._errors (alternatively, use an arrayProxy).


Setting field errors with refine


You may want to set the error on the password or the confirm field instead of a form-level error. In that case you can add a path to the Zod refine option:


const refined = z.object({
  tags: z.string().array().max(3)
  password: z.string().min(8),
  confirm: z.string().min(8)
})
.refine((data) => data.password == data.confirm, {
  message: "Passwords didn't match",
  path: ["confirm"]
});
As said, setting errors on the schema like this is preferred, but it may not always be possible. When you need to set errors after validation, use the setError function.


If you would like a message to persist until the next form submission regardless of validation, use a status message instead.


Listing errors


You may also want to list the errors above the form. The $allErrors store can be used for this. It’s an array that contains all errors and their field names:


{#if $allErrors.length}
  <ul>
    {#each $allErrors as error}
      <li>
        <b>{error.path}:</b>
        {error.messages.join('. ')}
      </li>
    {/each}
  </ul>
{/if}
$allErrors.length can also be useful to disable the submit button if there are any errors.


Customizing error messages in the schema


Most methods in the validation schema has a parameter for a custom error message, so you can just add them there. For example with Zod:


const schema = z.object({
  name: z.string().min(2, "Name is too short."),
  email: z.string().email("That's a strange email.")
});
This is also a good place for translation strings.


Test it out


This form has aria-invalid set on erroneous fields, and lists all errors on top of the form using $allErrors. Try to submit and see that the first error field gets focus automatically (unless on mobile).


Name * 
E-mail * 
Submit


Events
A number of events give you full control over the submit process. They are triggered every time the form is submitted.


Events are only available when JavaScript is enabled in the browser and the custom use:enhance is added to the form.


Event flowchart


In a single-page application, or if client-side validation fails, the validation happens entirely on the client, instead of being returned from the server between onSubmit and onResult.


Usage


const { form, enhance } = superForm(data.form, {
  onSubmit: ({ action, formData, formElement, controller, submitter, cancel }) => void
  onResult: ({ result, formEl, cancel }) => void
  onUpdate: ({ form, cancel }) => void
  onUpdated: ({ form }) => void
  onError: (({ result, message }) => void) | 'apply'
})
onSubmit


onSubmit: ({
  action, formData, formElement, controller, submitter, cancel,
  jsonData, validators
}) => void;
The onSubmit event is the first one triggered, being essentially the same as SvelteKit’s own use:enhance function. It gives you a chance to cancel the submission altogether. See the SvelteKit docs for most of the SubmitFunction signature. There are two extra properties in the Superforms onSubmit event:


jsonData


If you’re using nested data, the formData property cannot be used to modify the posted data, since $form is serialized and posted instead. If you want to post something else than $form, you can do it with the jsonData function:


import { superForm, type FormPath } from 'sveltekit-superforms'


const { form, enhance, isTainted } = superForm(data.form, {
  dataType: 'json',
  onSubmit({ jsonData }) {
    // Only post tainted (top-level) fields
    const taintedData = Object.fromEntries(
      Object.entries($form).filter(([key]) => {
        return isTainted(key as FormPath<typeof $form>)
      })
    )
    // Set data to be posted
    jsonData(taintedData);
  }
});
Note that if client-side validation is enabled, it’s always $form that will be validated. Only if it passes validation, the data sent with jsonData will be used. It does not work in SPA mode either, as data transformation can be handled in onUpdate in that case.


validators


For advanced validation, you can change client-side validators for the current form submission with this function.


import { superForm } from 'sveltekit-superforms';
import { zod } from 'sveltekit-superforms/adapters';
import { customSchema } from './schemas.js';


let step = 1;
const lastStep = 5;


const { form, enhance } = superForm(data.form, {
  onSubmit({ validators }) {
    if(step == 1) validators(zod(customSchema));
    else if(step == lastStep) validators(false);
  }
});
onResult


onResult: ({ result, formElement, cancel }) => void
If the submission isn’t cancelled and client-side validation succeeds, the form is posted to the server. It then responds with a SvelteKit ActionResult, triggering the onResult event.


result contains the ActionResult. You can modify it; changes will be applied further down the event chain. formElement is the HTMLFormElement of the form. cancel() is a function which will cancel the rest of the event chain and any form updates.


In most cases, you don’t have to care about the ActionResult. To check if the form validation succeeded, use onUpdated, or onUpdate if you want to modify or cancel the result before it’s displayed.


Common usage


onResult is useful when you have set applyAction = false and still want to redirect, since the form doesn’t do that automatically in that case. Then you can do:


const { form, enhance } = superForm(data.form, {
  applyAction: false,
  onResult({ result }) {
    if (result.type === 'redirect') {
      goto(result.location);
    }
  }
});
Also, if applyAction is false, which means that $page.status won’t update, you’ll find the status code for the request in result.status.


Strongly typed ActionResult


Usually, you check the ActionResult status in onResult, not the form validation result, which is more conveniently handled in onUpdate (see below). But if you return additional data in the form action, there is a helper type called FormResult, that you can use to make the ActionResult data strongly typed:


<script lang="ts">
  import { superForm, type FormResult } from 'sveltekit-superforms';
  import type { ActionData } from './$types.js';


  export let data;


  const { form, enhance } = superForm(data.form, {
    onResult: (event) => {
      const result = event.result as FormResult<ActionData>;
      if (result.type == 'failure') {
        // Strongly typed now (but quite unreadable,
        // prefer to use onUpdate or onUpdated)
        console.log(result.data?.form.data.name);
      }
    }
  });
</script>
onUpdate


onUpdate: ({ form, formElement, cancel }) => void
The onUpdate event is triggered right before the form update is being applied, giving you the option to modify the validation result in form, or use cancel() to negate the update altogether. You also have access to the form’s HTMLFormElement with formElement.


If your app is a single-page application, use onUpdate to process the form data. See the SPA page for more details.


When you don’t need to modify or cancel the validation result, the last event is the most convenient to use:


onUpdated


onUpdated: ({ form }) => void
When you just want to ensure that the form is validated and do something extra afterwards, like showing a toast notification, onUpdated is the easiest way.


The form parameter contains the validation result, and should be considered read-only here, since the stores have updated at this point.


Example


const { form, enhance } = superForm(data.form, {
  onUpdated({ form }) {
    if (form.valid) {
      // Successful post! Do some more client-side stuff,
      // like showing a toast notification.
      toast(form.message, { icon: '✅' });
    }
  }
});
onError


onError: (({ result }) => void) | 'apply'
When the SvelteKit error function is called on the server, you can use the onError event to catch it.


result is the error ActionResult, with the error property casted to App.Error. In this simple example, the message store is set to the error:


const { form, enhance, message } = superForm(data.form, {
  onError({ result }) {
    $message = result.error.message;
  }
});
You can also set onError to the string value 'apply', in which case the SvelteKit applyAction error behaviour will be used, which is to render the nearest +error page, also wiping out the form. To avoid data loss even for non-JavaScript users, returning a status message instead of throwing an error is recommended.


If you’re unsure what event to use, start with onUpdated; unless your app is a SPA, then onUpdate should be used to validate the form data.


Non-submit events


onChange


The onChange event is not triggered when submitting, but every time $form is modified, both as a html event (when modified with bind:value) and programmatically (direct assignment to $form).


The event is a discriminated union that you can distinguish between using the target property:


const { form, errors, enhance } = superForm(data.form, {
  onChange(event) {
    if(event.target) {
      // Form input event
      console.log(
        event.path, 'was changed from', event.target, 
        'in form', event.formElement
      );
    } else {
      // Programmatic event
      console.log('Fields updated:', event.paths)
    }
  }
})
If you only want to handle programmatic events, you can access event.paths without distinguishing.


File uploads
From version 2, Superforms has full support for file uploads. For that, you need a schema that can validate files. Zod has this possibility:


import { fail } from '@sveltejs/kit';
import { superValidate, withFiles } from 'sveltekit-superforms';
import { zod } from 'sveltekit-superforms/adapters';
import { z } from 'zod';


const schema = z.object({
  image: z
    .instanceof(File, { message: 'Please upload a file.'})
    .refine((f) => f.size < 100_000, 'Max 100 kB upload size.')
    .nullable()
});


export const load = async () => {
  return { 
    form: await superValidate(zod(schema))
  }
};


export const actions = {
  default: async ({ request }) => {
    const form = await superValidate(request, zod(schema));


    if (!form.valid) {
      return fail(400, withFiles({ form }));
    }


    // TODO: Do something with the image
    console.log(form.data.image);


    // See note about withFiles further down
    return withFiles({ form });
  }
};
The file field has to be nullable, as that is the default value for empty files. If you want the upload to be optional, set the field to nullish, to allow undefined as well.


Then you need a form with the proper enctype value on the form, and a file input field:


<form method="POST" enctype="multipart/form-data">
  <input type="file" name="image" /> 
  <button>Submit</button>
</form>
Examples


The examples show how to add file validation even on the client, with an on:input handler.


Single file input


As mentioned before, the field needs to be nullable. If you want the upload to be optional, set the field to nullish.


export const schema = z.object({
  image: z
    .instanceof(File, { message: 'Please upload a file.'})
    .refine((f) => f.size < 100_000, 'Max 100 kB upload size.')
    .nullable()
});
<script lang="ts">
  import { superForm } from 'sveltekit-superforms'
  import { zodClient } from 'sveltekit-superforms/adapters'
  import { schema } from './schema.js'


  export let data;


  const { form, enhance, errors } = superForm(data.form, {
    validators: zodClient(schema)
  })
</script>


<form method="POST" enctype="multipart/form-data" use:enhance>
  <input
    type="file"
    name="image"
    accept="image/png, image/jpeg"
    on:input={(e) => ($form.image = e.currentTarget.files?.item(0) ?? null)}
  />
  {#if $errors.image}<span>{$errors.image}</span>{/if}
  <button>Submit</button>
</form>
Multiple files


We need an array to validate multiple files:


const schema = z.object({
  images: z
    .instanceof(File, { message: 'Please upload a file.'})
    .refine((f) => f.size < 100_000, 'Max 100 kB upload size.')
    .array()
});


const form = await superValidate(formData, zod(schema));
<script lang="ts">
  import { superForm } from 'sveltekit-superforms'
  import { zodClient } from 'sveltekit-superforms/adapters'
  import { schema } from './schema.js'


  export let data;


  const { form, enhance, errors } = superForm(data.form, {
    validators: zodClient(schema)
  })
</script>


<form method="POST" enctype="multipart/form-data" use:enhance>
  <input
    type="file"
    multiple
    name="images"
    accept="image/png, image/jpeg"
    on:input={(e) => ($form.images = Array.from(e.currentTarget.files ?? []))}
  />
  {#if $errors.images}<span>{$errors.images}</span>{/if}
  <button>Submit</button>
</form>
Form action caveat - withFiles


There’s one important thing to be aware of: Because file objects cannot be serialized, you must use a withFiles helper function when you return a form containing files:


import { fail } from '@sveltejs/kit';
import { withFiles, message, setError } from 'sveltekit-superforms';


// When using fail
if (!form.valid) return fail(400, withFiles({ form }));


// When returning just the form:
return withFiles({ form })


// message and setError handles this automatically:
return message(form, 'Posted OK!');
return setError(form, 'image', 'Could not process file.');
This will remove the file objects from the form data before returning, so SvelteKit can serialize it properly.


Validating files manually


If your validation library cannot validate files, you can obtain FormData from the request and extract the files from there, after validation:


export const actions = {
  default: async ({ request }) => {
    const formData = await request.formData();
    const form = await superValidate(formData, zod(schema));


    if (!form.valid) return fail(400, withFiles({ form }));


    const image = formData.get('image');
    if (image instanceof File) {
      // Validate and process the image.
    }


    return withFiles({ form });
  }
};
If the file field isn’t a part of the schema, but you still want errors for it, you can add an optional field to the schema with the same name, and use setError to set and display an error message.


Preventing file uploads


To prevent file uploads, set the { allowFiles: false } option in superValidate. This will set all files to undefined, so you don’t have to use withFiles.


This will also happen if you have migrated from version 1 and defined SUPERFORMS_LEGACY. In that case, set { allowFiles: true } to allow files.


Loading timers
It’s important that users understand that things are happening when they submit a form. Loading timers can be used to provide feedback when there is a server response delay, for example by displaying a loading spinner icon.


Usage


const { form, enhance, submitting, delayed, timeout } = superForm(data.form, {
  delayMs?: 500
  timeoutMs?: 8000
})
delayMs should be positive and always smaller than or equal to timeoutMs, otherwise the timer behavior will be undefined. And of course, the Superforms use:enhance must be added to the form element, since this is client-side behavior.


Submit state


After a certain time when the form is submitted, determined by delayMs and timeoutMs, the timers changes state. The states are:


Idle → submitting → delayed → timeout
       0 ms         500 ms    8000 ms
These states affect the readable stores submitting, delayed and timeout, returned from superForm. They are not mutually exclusive, so submitting won’t change to false when delayed becomes true.


Loading indicators


A perfect use for these timers is to show a loading indicator while the form is submitting:


src/routes/+page.svelte


<script lang="ts">
  const { form, errors, enhance, delayed } = superForm(data.form);
  import spinner from '$lib/assets/spinner.svg';
</script>


<form method="POST" use:enhance>
  <button>Submit</button>
  {#if $delayed}<img src={spinner} />{/if}
</form>
The reason for using delayed instead of submitting is based on the article Response Times: The 3 Important Limits, which states that for short waiting periods, no feedback is required except to display the result. Therefore, delayed is used to show a loading indicator after a little while, not instantly.


Visualizing the timers


Submit the following form and play around with the different settings. Different loading spinners are set to display when delayed and timeout are true respectively.


The default multipleSubmits setting prevents the form from being submitted multiple times, until the timeout state is reached. Click multiple times to see the effect of that.


Idle → submitting → delayed → timeout
       0 ms         500 ms    2000 ms
Server response delay: 4000 ms


delayMs option: 500 ms


timeoutMs option: 2000 ms


Submit
By experimenting with the timers and the delay between them, it’s certainly possible to prevent the feeling of unresponsiveness.


Multiple forms on the same page
Since there is only one $page store per route, multiple forms on the same page, like a register and login form, can cause problems since both form actions will update $page.form, possibly affecting the other form.


With Superforms, multiple forms on the same page are handled automatically if you are using use:enhance, and the forms have different schema types. When using the same schema for multiple forms, you need to set the id option:


const form = await superValidate(zod(schema), {
  id: string | undefined
});
By setting an id on the server, you’ll ensure that only forms with the matching id on the client will react to the updates.


“Different schema types” means “different fields and types”, so just copying a schema and giving it a different variable name will still count as the same schema. The contents of the schemas have to differ.


Here’s an example of how to handle a login and registration form on the same page:


+page.server.ts


import { z } from 'zod';
import { fail } from '@sveltejs/kit';
import { message, superValidate } from 'sveltekit-superforms';
import { zod } from 'sveltekit-superforms/adapters';


const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8)
});


const registerSchema = z.object({
  email: z.string().email(),
  password: z.string.min(8),
  confirmPassword: z.string.min(8)
});


export const load = async () => {
  // Different schemas, no id required.
  const loginForm = await superValidate(zod(loginSchema));
  const registerForm = await superValidate(zod(registerSchema));


  // Return them both
  return { loginForm, registerForm };
};


export const actions = {
  login: async ({ request }) => {
    const loginForm = await superValidate(request, zod(loginSchema));


    if (!loginForm.valid) return fail(400, { loginForm });


    // TODO: Login user
    return message(loginForm, 'Login form submitted');
  },


  register: async ({ request }) => {
    const registerForm = await superValidate(request, zod(registerSchema));


    if (!registerForm.valid) return fail(400, { registerForm });


    // TODO: Register user
    return message(registerForm, 'Register form submitted');
  }
};
The code above uses named form actions to determine which form was posted. On the client, you’ll post to these different form actions for the respective form:


+page.svelte


<script lang="ts">
  import { superForm } from 'sveltekit-superforms/client';
  import type { PageData } from './$types.js';


  export let data: PageData;


  const { form, errors, enhance, message } = superForm(data.loginForm, {
    resetForm: true
  });


  const {
    form: registerForm,
    errors: registerErrors,
    enhance: registerEnhance,
    message: registerMessage
  } = superForm(data.registerForm, {
    resetForm: true
  });
</script>


{#if $message}<h3>{$message}</h3>{/if}


<form method="POST" action="?/login" use:enhance>
  E-mail: <input name="email" type="email" bind:value={$form.email} />
  Password:
  <input name="password" type="password" bind:value={$form.password} />
  <button>Submit</button>
</form>


<hr />


{#if $registerMessage}<h3>{$registerMessage}</h3>{/if}


<form method="POST" action="?/register" use:registerEnhance>
  E-mail: <input name="email" type="email" bind:value={$registerForm.email} />
  Password:
  <input name="password" type="password" bind:value={$registerForm.password} />
  Confirm password:
  <input
    name="confirmPassword"
    type="password"
    bind:value={$registerForm.confirmPassword} />
  <button>Submit</button>
</form>
Note that there is a separate use:enhance for each form - you cannot share the enhance action between forms.


The above works well with forms that posts to a dedicated form action. But for more dynamic scenarios, let’s say a database table where rows can be edited, the form id should correspond to the row id, and you’d want to communicate to the server which id was sent. This can be done by modifying the $formId store, to let the server know what id was posted, and what it should respond with.


Setting id on the client


On the client, the id is picked up automatically when you pass data.form to superForm, so in general, you don’t have to add it on the client.


// Default behavior: The id is sent along with the form data
// sent from the load function.
const { form, enhance, formId } = superForm(data.loginForm);


// In advanced cases, you can set the id as an option
// and it will take precedence.
const { form, enhance, formId } = superForm(data.form, {
  id: 'custom-id'
});
You can also change the id dynamically with the $formId store, or set it directly in the form with the following method:


Without use:enhance


Multiple forms also work without use:enhance, though in this case you must add a hidden form field called __superform_id with the $formId value:


<script lang="ts">
  import { superForm } from 'sveltekit-superforms/client';
  import type { PageData } from './$types.js';


  export let data: PageData;


  const { form, errors, formId } = superForm(data.form);
</script>


<form method="POST" action="?/login">
  <input type="hidden" name="__superform_id" bind:value={$formId} />
</form>
This is also required if you’re changing schemas in a form action, as can happen in multi-step forms.


Configuration and troubleshooting


Due to the many different use cases, it’s hard to set sensible default options for multiple forms. A common issue is that when one form is submitted, the other forms’ data are lost. This is due to the page being invalidated by default on a successful response.


If you want to preserve their data, you’d almost certainly want to set invalidateAll: false or applyAction: false on them, as in the example above. The use:enhance option explains the differences between them.


Also check out the componentization page for ideas on how to place the forms into separate components, to make +page.svelte less cluttered.


Test it out


Here we have two forms, with separate id’s and their invalidateAll option set to false, to prevent page invalidation, which would otherwise clear the other form when the load function executes again.




Toggle SuperDebug




200
{
  $register: {
    name: "",
    email: "",
    pwd: ""
  },
  $login: {
    email: "",
    pwd: ""
  }
}


Register user
Name 
E-mail 
Password 
Submit
Login
E-mail 
Password 
Submit


Nested data
HTML forms can only handle string values, and the <form> element cannot nest other forms, so there is no standardized way to represent a nested data structure or more complex values like dates. Fortunately, Superforms has a solution for this!


Usage


const { form, enhance } = superForm(data.form, {
  dataType: 'form' | 'json' = 'form'
})
dataType


By simply setting dataType to 'json', you can store any data structure allowed by devalue in the $form store, and you don’t have to worry about failed coercion, converting strings to objects and arrays, etc.


You don’t even have to set a name on the form fields anymore, since the actual data in $form is now posted, not the input fields in the HTML. They are now simply UI components for modifying a data model (as they should be).


When dataType is set to 'json', the onSubmit event will contain FormData, but it cannot be used to modify the posted data. You need to set or update $form, or in special cases, use jsonData in onSubmit.


This also means that the disabled attribute, which normally prevents input fields from being submitted, will not have that effect. Everything in $form will be posted when dataType is set to 'json'.


Modifying the form store programmatically is easy, you can either assign $form.field = ... directly, which will taint the affected fields. If you want to prevent the form from being tainted, you can use form.update with an extra option:


form.update(
  ($form) => {
    $form.name = "New name";
    return $form;
  },
  { taint: false }
);
The taint options are:


{ taint: boolean | 'untaint' | 'untaint-form' }
Which can be used to not only prevent tainting, but also untaint the modified field(s), or the whole form.


Requirements


The requirements for nested data to work are as follows:


JavaScript is enabled in the browser.
The form has the Superforms use:enhance applied.
Nested errors and constraints


When your schema contains arrays or objects, you can access them through $form as an ordinary object. But how does it work with errors and constraints?


$errors and $constraints actually mirror the $form data, but with every field or “leaf” in the object replaced with string[] and InputConstraints respectively.


Example


Given the following schema, which describes an array of tag objects:


const schema = z.object({
  tags: z
    .object({
      id: z.number().int().min(1),
      name: z.string().min(2)
    })
    .array()
});


const tags = [{ id: 1, name: 'test' }];


export const load = async () => {
  const form = await superValidate({ tags }, zod(schema));
  return { form };
};
You can build a HTML form for these tags using an {#each} loop:


<script lang="ts">
  const { form, errors, enhance } = superForm(data.form, {
    dataType: 'json'
  });
</script>


<form method="POST" use:enhance>
  {#each $form.tags as _, i}
    <div>
      Id
      <input
        type="number"
        data-invalid={$errors.tags?.[i]?.id}
        bind:value={$form.tags[i].id} />
      Name
      <input
        data-invalid={$errors.tags?.[i]?.name}
        bind:value={$form.tags[i].name} />
      {#if $errors.tags?.[i]?.id}
        <br />
        <span class="invalid">{$errors.tags[i].id}</span>
      {/if}
      {#if $errors.tags?.[i]?.name}
        <br />
        <span class="invalid">{$errors.tags[i].name}</span>
      {/if}
    </div>
  {/each}
  <button>Submit</button>
</form>
Take extra care with the optional chaining operator ?., it’s easy to miss a question mark, which will lead to confusing errors.


Note that we’re using the index of the loop, so the value can be bound directly to $form. You can’t use the each loop variable, hence the underscore. This is what it looks like:




Toggle SuperDebug
200
{
  tags: [
    {
      id: 0,
      name: "test"
    },
    {
      id: 7,
      name: "a"
    }
  ]
}
Id
0
Name
test
Id
7
Name
a
Submit
Arrays with primitive values


It’s possible to post multiple HTML elements with the same name, so you don’t have to use dataType: 'json' for arrays of primitive values like numbers and strings. Just add the input fields, all with the same name as the schema field, which can only be at the top level of the schema. Superforms will handle the type coercion to array automatically, as long as the fields have the same name attribute:


export const schema = z.object({
  tags: z.string().min(2).array().max(3)
});
<script lang="ts">
  const { form, errors } = superForm(data.form);
</script>


<form method="POST">
  <div>Tags</div>
  {#if $errors.tags?._errors}
    <div class="invalid">{$errors.tags._errors}</div>
  {/if}


  {#each $form.tags as _, i}
    <div>
      <input name="tags" bind:value={$form.tags[i]} />
      {#if $errors.tags?.[i]}
        <span class="invalid">{$errors.tags[i]}</span>
      {/if}
    </div>
  {/each}


  <button>Submit</button>
</form>
To summarize, the index i of the #each loop is used to access $form.tags, where the current values are (you cannot use the loop variable), and then the name attribute is set to the schema field tags, so its array will be populated when posted.


This example, having a max(3) limitation of the number of tags, also shows how to display array-level errors with the $errors.tags._errors field.


Proxy objects
Sometimes you get a string value from an input field or third-party library, and want it to be automatically converted and updated with a non-string value in your schema. This is what proxies are for.


import {
  // The primitives return a Writable<string>:
  booleanProxy,
  dateProxy,
  intProxy,
  numberProxy,
  stringProxy,
  // The type of the other three depends on the field:
  formFieldProxy,
  arrayProxy,
  fieldProxy      
} from 'sveltekit-superforms';
The usage for all of them is practically the same. You can use the form store, or the whole superForm as input, which allows you to set a tainted option, in case you don’t want to taint the form when it updates.


import { superForm, intProxy } from 'sveltekit-superforms';


// Assume the following schema:
// { id: number }


const theForm = superForm(data.form);
const { form, errors, enhance } = theForm;


// Returns a Writable<string>
const idProxy = intProxy(form, 'id');


// Use the whole superForm object to prevent tainting
const idProxy2 = intProxy(theForm, 'id', { taint: false });
Now if you bind to $idProxy instead of $form.id, the value will be converted to and from an integer, and $form.id will be updated automatically.


Note that this kind of conversion will usually happen automatically with bind:value. intProxy and numberProxy are rarely needed, as Svelte handles this automatically. But proxies may still be useful if you want to set the value to undefined or null when the value is falsy, in which case you can use the empty option.


See the API for more details and options for each kind of proxy.


Nested proxies


You can use a proxy for nested data, like 'user.profile.email', in which case parent objects will be created if they don’t exist.


Date input issues


The date input type is a bit special. Its underlying data is a string in yyyy-mm-dd format, but the dateProxy returns an ISO date string as default, so you need to use the format option to return the date part only:


const proxyDate = dateProxy(form, 'date', { format: 'date' });
<input
  name="date"
  type="date"
  bind:value={$proxyDate}
  aria-invalid={$errors.date ? 'true' : undefined}
  {...$constraints.date}
  min={$constraints.date?.min?.toString().slice(0, 10)}
  max={$constraints.date?.max?.toString().slice(0, 10)}
/>
We’re also taking using the min and max constraints to limit the date picker selection. The following example limits the date from today and forward, and also uses the empty option of the proxy, to set an invalid date to undefined:




Toggle SuperDebug
200
{
  date: undefined
}
Date 
dd/mm/yyyy
Submit


Single-page applications (SPA)
It’s possible to use the whole Superforms library on the client in single page applications. A SPA is easy to create with SvelteKit, fully documented here.


Usage


const { form, enhance } = superForm(data, {
  SPA: true | { failStatus: number }
  validators: false | ClientValidationAdapter<S>
})
By setting the SPA option to true, the form won’t be sent to the server when submitted. Instead, the client-side validators option will determine the success or failure of the form, which will trigger the event chain, and the validation result will be most conveniently used in the onUpdate event, for example by calling an external API.


Remember that the Superforms use:enhance must be added to the form for SPA to work.


Using +page.ts instead of +page.server.ts


Since SPA pages don’t have a server representation, you can use +page.ts to load initial data. Combined with a route parameter, we can make a CRUD-like page in a straightforward manner:


src/routes/user/[id]/+page.ts


import { error } from '@sveltejs/kit';
import { superValidate } from 'sveltekit-superforms/client';
import { zod } from 'sveltekit-superforms/adapters';
import { z } from 'zod';


export const _userSchema = z.object({
  id: z.number().int().positive(),
  name: z.string().min(2),
  email: z.string().email()
});


export const load = async ({ params, fetch }) => {
  const id = parseInt(params.id);


  const request = await fetch(
    `https://jsonplaceholder.typicode.com/users/${id}`
  );
  if (request.status >= 400) throw error(request.status);


  const userData = await request.json();
  const form = await superValidate(userData, zod(_userSchema));


  return { form };
};
If no data should be loaded from +page.ts, read further down about the defaults function.


Displaying the form


We display the form in +page.svelte like before, but with the SPA option added, and the onUpdate event now being used to validate the form data, instead of on the server:


src/routes/user/[id]/+page.svelte


<script lang="ts">
  import { superForm, setMessage, setError } from 'sveltekit-superforms/client';
  import { _userSchema } from './+page.js';


  export let data;


  const { form, errors, message, constraints, enhance } = superForm(
    data.form,
    {
      SPA: true,
      validators: _userSchema,
      onUpdate({ form }) {
        // Form validation
        if (form.data.email.includes('spam')) {
          setError(form, 'email', 'Suspicious email address.');
        } else if (form.valid) {
          // TODO: Call an external API with form.data, await the result and update form
          setMessage(form, 'Valid data!');
        }
      }
    }
  );
</script>


<h1>Edit user</h1>


{#if $message}<h3>{$message}</h3>{/if}


<form method="POST" use:enhance>
  <label>
    Name<br />
    <input
      aria-invalid={$errors.name ? 'true' : undefined}
      bind:value={$form.name}
      {...$constraints.name} />
  </label>
  {#if $errors.name}<span class="invalid">{$errors.name}</span>{/if}


  <label>
    E-mail<br />
    <input
      type="email"
      aria-invalid={$errors.email ? 'true' : undefined}
      bind:value={$form.email}
      {...$constraints.email} />
  </label>
  {#if $errors.email}<span class="invalid">{$errors.email}</span>{/if}


  <button>Submit</button>
</form>
The validation in onUpdate is almost the same as validating in a form action on the server. Nothing needs to be returned at the end since all modifications to the form parameter in onUpdate will update the form.


Of course, since this validation is done on the client, it’s easy to tamper with. See it as a convenient way of collecting the form data before doing a proper server validation through an external API.


Without a +page.ts file


Since you can’t use top-level await in Svelte components, you can’t use superValidate directly in +page.svelte, as it is async. But if you want the default values only for the schema, you can import defaults to avoid having a +page.ts.


<script lang="ts">
  import { superForm, defaults } from 'sveltekit-superforms';
  import { zod } from 'sveltekit-superforms/adapters';
  import { loginSchema } from '$lib/schemas';


  const { form, errors, enhance } = superForm(defaults(zod(loginSchema)), {
    SPA: true,
    validators: zod(loginSchema),
    onUpdate({ form }) {
      if (form.valid) {
        // TODO: Do something with the validated form.data
      }
    }
  });
</script>
With initial top-level data


If you have initial data in the top level of the component, you can pass it as a first parameter to defaults, but remember that it won’t be validated. There’s a trick though; if you want to show errors for the initial data, you can call validate directly after superForm. The validators option must be set for this to work:


const initialData = { name: 'New user' };


const { form, errors, enhance, validate } = superForm(
  defaults(initialData, zod(loginSchema)), {
    SPA: true,
    validators: zod(loginSchema)
    // ...
  }
);


validate({ update: true });
Test it out


The following form has SPA: true set, and is using +page.ts for loading the initial data. Take a look in the browser devtools and see that nothing is posted to the server on submit.


Name 
SPA user
E-mail 
spa@spam.web
Submit


Snapshots
A nice SvelteKit feature is snapshots, which saves and restores data when the user navigates on the site. This is perfect for saving the form state, and with Superforms, you can take advantage of this in one line of code, as an alternative to a tainted form message. Note that it only works for browser history navigation though.


Usage


const { form, capture, restore } = superForm(data.form);


export const snapshot = { capture, restore };
The export has to be on a +page.svelte page to work, it cannot be in a component.


The options object contains functions and cannot be serialized for a snapshot. If you modify the options dynamically, make a custom version of the methods to handle the changes.


Test it out


Modify the form below without submitting, then click the browser back button and then forward again. The form should be restored to its intermediate state.


Name 
E-mail 
Submit Reset


Status messages
A status message like “Form posted” can be displayed after submitting a form. The validation object contains a message store used for this:


Usage


const { form, message } = superForm(data.form);
It is used to display the message on the client, like any other store:


{#if $message}
  <div class="message">{$message}</div>
{/if}
However, we need to send it from the server first. Using the message function makes this rather simple.


The message helper


import { message, superValidate } from 'sveltekit-superforms';
import { zod } from 'sveltekit-superforms/adapters';


export const actions = {
  default: async ({ request }) => {
    const form = await superValidate(request, zod(schema));


    if (!form.valid) {
      // Will return fail(400, { form }) since form isn't valid
      return message(form, 'Invalid form');
    }


    if (form.data.email.includes('spam')) {
      // Will also return fail, since status is >= 400
      // form.valid will also be set to false.
      return message(form, 'No spam please', {
        status: 403
      });
    }


    // Just returns { form } with the message (and status code 200).
    return message(form, 'Valid form!');
  }
};
You can return any type with the message, like an object, if you want to send more information than a string:


return message(form, { text: 'User created', id: newId })
See right below for how to make this data strongly typed.


A successful form action in SvelteKit can only return status code 200, so the status option for message must be in the range 400-599, otherwise { form } will be returned with a status of 200, no matter what the status option is set to.


Strongly typed message


The message is of type any by default, but you can type it using the superValidate type parameters:


import { type Infer, superValidate } from 'sveltekit-superforms';
import { zod } from 'sveltekit-superforms/adapters';


// Inferred schema type as first parameter, message type second
const form = await superValidate<Infer<typeof schema>, string>(event, zod(schema));
A string can be a bit limiting though; more realistically, there will be some kind of status for the form submission, so making a Message type can be useful for consistency.


import { type Infer, superValidate } from 'sveltekit-superforms';
import { zod } from 'sveltekit-superforms/adapters';


type Message = { status: 'error' | 'success' | 'warning'; text: string };


const form = await superValidate<Infer<typeof schema>, Message>(event, zod(schema));
To simplify this even further, if you have the same type for all status messages across the project, you can add a Message type to the App.Superforms namespace in src/app.d.ts, and it will be automatically set, no need for generic type parameters:


src/app.d.ts


declare global {
  namespace App {
    // interface Error {}
    // interface Locals {}
    // interface PageData {}
    // interface Platform {}
    namespace Superforms {
      type Message = {
        type: 'error' | 'success', text: string
      }
    }
  }
}
src/routes/+page.svelte


<script lang="ts">
  import type { PageData } from './$types.js';
  export let data: PageData;


  const { form, message } = superForm(data.form);
</script>


{#if $message}
  <div 
    class:success={$message.status == 'success'} 
    class:error={$message.status == 'error'}
  >
    {$message.text}
  </div>
{/if}
Though if you want to keep it simple with a string or the default any, you can use $page.status to style the message appropriately:


<script lang="ts">
  import { page } from '$app/stores';
  import type { PageData } from './$types.js';


  export let data: PageData;


  const { form, message } = superForm(data.form);
</script>


{#if $message}
  <div 
    class:success={$page.status == 200} 
    class:error={$page.status >= 400}
  >
    {$message}
  </div>
{/if}
Using the message data programmatically


If you return data that you want to use programmatically instead of just displaying it, like in a toast message, you can do that in the onUpdate or onUpdated event:


return message(form, { status: 'success', text: 'All went well' });
const { form, enhance } = superForm(data.form, {
  onUpdated({ form }) {
    if (form.message) {
      // Display the message using a toast library
      toast(form.message.text, {
        icon: form.message.status == 'success' ? '✅' : '❌'
      });
    }
  }
});
The difference between the two events is that you can modify and cancel the update in onUpdate, compared to onUpdated, where the form data, errors, etc have already updated, making it best for non-store-related things like displaying a toast.


Limitations


Since there is no form data returned when redirecting, in that case the message will be lost. It’s quite common to redirect after a successful post, so the message property isn’t a general solution for displaying status messages.


The library sveltekit-flash-message is a complete solution that works with redirects, however. It can be directly integrated into Superforms, documented here.


Strict mode
Superforms is quite forgiving with missing fields in the posted data. The assumption is that if you add a field to a schema, it will sooner or later be added to the form, so the default value is applied to all missing schema fields.


But you may want to be more strict and assert that the input data must exist, otherwise something is wrong. For that, you can use strict mode when calling superValidate:


const form = await superValidate(request, zod(schema), { strict: true });
Now the following will be true:


Any missing required field will be reported as an error.
Errors will be displayed as default (can be changed with the errors option).
Catch-all schema


Some validation libraries have a “catch-all” feature, allowing extra fields to be posted and validated. Here’s an example of how to use it with Zod:


import { superValidate } from 'sveltekit-superforms';
import { zod } from 'sveltekit-superforms/adapters';
import { z } from 'zod';


const schema = z.object({
  name: z.string().min(1)
})
.catchall(z.number().int()); // All unknown fields should be integers


export const actions = {
  default: async ({ request }) => {
    const form = await superValidate(request, zod(schema));


    if (!form.valid) {
      return fail(400, { form });
    }


    // Typed as string, as expected
    console.log(form.data.name);
    // All other keys are typed as number
    console.log(form.data.first, form.data.second);


    return { form };
  }
};


Submit behavior
When a form is submitted, it’s important for the UX to show that things are happening on the server. Superforms provides you with loading timers and the following options for handling this:


Usage


const { form, enhance } = superForm(data.form, {
  clearOnSubmit: 'errors' | 'message' | 'errors-and-message' | 'none' = 'errors-and-message'
  multipleSubmits: 'prevent' | 'allow' | 'abort' = 'prevent'
})
clearOnSubmit


The clearOnSubmit option decides what should happen to the form when submitting. It can clear all the errors, the message, both, or none. The default is to clear both.


If you don’t want any jumping content, which could occur when error messages are removed from the DOM, setting it to one of the other options can be useful.


multipleSubmits


This one handles the occurence of multiple form submissions, before a result has been returned.


When set to prevent, the form cannot be submitted again until a result is returned, or the timeout state is reached (see the section about loading timers).
abort is the next sensible approach, which will cancel the previous request before submitting again.
Finally, allow will pass through any number of frenetic clicks on the submit button!


Tainted fields
When the form data is modified, through modifying $form, the modified data (and in turn the form), is considered tainted, also known as “dirty” in other form libraries.


A Superforms feature is to prevent the user from losing data when navigating away from a tainted form.


Usage


const { form, enhance } = superForm(data.form, {
  taintedMessage: string | (() => Promise<boolean>) | boolean = false
})
You can set the option to true to have a default message (in english) shown when navigating away from a tainted form, or set your own message with a string value. Note that this message will only be displayed when navigating to a page within the same site. When closing the tab or reloading the page, a browser default message will be shown instead.


Alternatively, you can set taintedMessage to a () => Promise<boolean> function that should resolve to true if navigating away is ok. This enables you to provide your own dialog:


const { form, enhance } = superForm(data.form, {
  taintedMessage: () => {
    return new Promise((resolve) => {
      modalStore.trigger({
        type: 'confirm',
        title: 'Do you want to leave?',
        body: 'Changes you made may not be saved.',
        response: resolve
      });
    });
  }
});
The code demonstrates the custom dialog with a Skeleton modal. Try it out below! Modify the form, then click the back button. A modal should pop up, preventing you from losing the changes:


Name * 
E-mail * 
Submit
Untainting the form


When a successful validation result is returned for the form, with a valid status set to true, the form is automatically marked as untainted.


Try that by posting the form with valid values. The tainted message should not appear when browsing away from the page.


Check if the form is tainted


An isTainted method is available on superForm, to check whether any part of the form is tainted:


<script lang="ts">
  const { form, enhance, tainted, isTainted } = superForm(form.data);


  // Check the whole form
  if(isTainted()) {
    console.log('The form is tainted')
  }


  // Check a part of the form
  if(isTainted('name')) {
    console.log('The name field is tainted')
  }
</script>


<!-- Make the function reactive by passing the $tainted store -->
<button disabled={!isTainted($tainted)}>Submit</button>


<!-- It even works with individual fields -->
<button disabled={!isTainted($tainted.name)}>Submit name</button>
Preventing tainting the form


If you want to modify the form store without tainting any fields, you can update it with an extra option:


const { form } = superForm(data.form);


form.update(
  ($form) => {
    $form.name = "New name";
    return $form;
  },
  { taint: false }
);
The taint options are:


{ taint: boolean | 'untaint' | 'untaint-form' }
Which can be used to not only prevent tainting, but also untaint the modified field(s), or untainting the whole form.


For login and registration forms, password managers could automatically taint the form when inserting saved usernames and passwords.


Progressive enhancement
By using enhance returned from superForm, we’ll get the client-side enhancement expected from a modern website:


<script lang="ts">
  const { form, enhance } = superForm(data.form);
  //            ^^^^^^^
</script>


<form method="POST" use:enhance>
The use:enhance action takes no arguments; instead, events are used to hook into the default SvelteKit use:enhance parameters and more. Check out the events page for details.


Without use:enhance (and JavaScript enabled in the browser), the form will be static. No events, loading timers, auto-focus, etc. The only things that will work are constraints. Also note that SvelteKit’s own use:enhance cannot be used; you must use the one returned from superForm, and it should only be used on a single form element - you cannot share it between forms.


Modifying the use:enhance behavior


The default use:enhance behavior can be modified, there are three options available, here shown with the default values; you don’t need to add them unless you want to change a value.


const { form, enhance, reset } = superForm(data.form, {
  applyAction: true,
  invalidateAll: true | 'force',
  resetForm: true
});
applyAction


When applyAction is true, the form will have the default SvelteKit behavior of both updating and reacting on $page.form and $page.status, and also redirecting automatically.


Turning this behavior off can be useful when you want to isolate the form from other sources updating the page, for example Supabase events, a known source of confusing form behavior. Read more about applyAction in the SvelteKit docs.


invalidateAll


When invalidateAll is true (the default) and a successful validation result is returned from the server, the page will be invalidated and the load functions will run again. A login form takes advantage of this to update user information on the page, but the default setting may cause problems with multiple forms on the same page, since the load function will reload the data for all forms defined there.


Optimistic updates


There can be a conflict between the data returned in the form action and the new data from the load function. The form action data is “optimistic”, meaning that what’s returned will be displayed, assuming that all data was supposed to be updated. But if you update the form partially, the form data will be out of sync with the load function data, in which case you may want to wait for the load function data. This can be achieved with by setting invalidateAll: 'force'. Now the load function data will be prioritized, and the reset function will also use the latest load function data when called.


resetForm


When true, reset the form upon a successful validation result.


Note however, that since we’re using bind:value on the input fields, a HTML form reset (clearing all fields in the DOM) won’t have any effect. So in Superforms, resetting means going back to the initial state of the form data, basically setting $form to what was initially sent to superForm.


For a custom reset, you can instead modify the data field returned from superValidate on the server, or use the events together with the reset function on the client.


When to change the defaults?


Quite rarely! If you have a single form on the page and nothing else is causing the page to invalidate, you’ll probably be fine as it is. For multiple forms on the same page, you have to experiment with these three options. Read more on the multiple forms page.


Making the form behave like the SvelteKit default


Any ActionResult with status error is transformed into failure by Superforms to avoid form data loss. The SvelteKit default is to render the nearest +error.svelte page, which will wipe out the form and all data that was just entered. Returning fail with a status message or using the onError event is a more user-friendly way of handling server errors.


You can prevent this by setting the following option. Use with care, since the purpose of the change is to protect the user from data loss.


const { form, enhance } = superForm(data.form, {
  // On ActionResult error, render the nearest +error.svelte page
  onError: 'apply',
});


Forms and fields in components
By looking at the rather simple get started tutorial, it’s obvious that quite a bit of boilerplate code adds up for a Superform:


<!-- For each form field -->
<label for="name">Name</label>
<input
  type="text"
  name="name"
  aria-invalid={$errors.name ? 'true' : undefined}
  bind:value={$form.name}
  {...$constraints.name} 
/>
{#if $errors.name}
  <span class="invalid">{$errors.name}</span>
{/if}
And it also gets bad in the script part when you have more than a couple of forms on the page:


<script lang="ts">
  import { superForm } from 'sveltekit-superforms'


  export let data;


  const {
    form: loginForm,
    errors: loginErrors,
    enhance: loginEnhance,
    //...
  } = superForm(data.loginForm);


  const {
    form: registerForm,
    errors: registerErrors,
    enhance: registerEnhance,
    // ...
  } = superForm(data.registerForm);
</script>
This leads to the question of whether a form and its fields can be factored out into components?


Factoring out a form


To do this, you need the type of the schema, which can be defined as follows:


src/lib/schemas.ts


export const loginSchema = z.object({
  email: z.string().email(),
  password: // ...
});


export type LoginSchema = typeof loginSchema;
Now you can import and use this type in a separate component:


src/routes/LoginForm.svelte


<script lang="ts">
  import type { SuperValidated, Infer } from 'sveltekit-superforms';
  import { superForm } from 'sveltekit-superforms'
  import type { LoginSchema } from '$lib/schemas';


  export let data: SuperValidated<Infer<LoginSchema>>;


  const { form, errors, enhance } = superForm(data);
</script>


<form method="POST" use:enhance>
  <!-- Business as usual -->
</form>
Use it by passing the form data from +page.svelte to the component, making it much less cluttered:


+page.svelte


<script lang="ts">
  export let data;
</script>


<LoginForm data={data.loginForm} />
<RegisterForm data={data.registerForm} />
If your schema input and output types differ, or you have a strongly typed status message, you can add two additional type parameters:


<script lang="ts">
  import type { SuperValidated, Infer, InferIn } from 'sveltekit-superforms';
  import { superForm } from 'sveltekit-superforms'
  import type { LoginSchema } from '$lib/schemas';


  export let data: SuperValidated<Infer<LoginSchema>, { status: number, text: string }, InferIn<LoginSchema>>;


  const { form, errors, enhance, message } = superForm(data);
</script>


{#if $message.text}
  ...
{/if}


<form method="POST" use:enhance>
  <!-- Business as usual -->
</form>
Factoring out form fields


Since bind is available on Svelte components, we can make a TextInput component quite easily:


TextInput.svelte


<script lang="ts">
  import type { InputConstraint } from 'sveltekit-superforms';


  export let value: string;
  export let label: string | undefined = undefined;
  export let errors: string[] | undefined = undefined;
  export let constraints: InputConstraint | undefined = undefined;
</script>


<label>
  {#if label}<span>{label}</span><br />{/if}
  <input
    type="text"
    bind:value
    aria-invalid={errors ? 'true' : undefined}
    {...constraints}
    {...$$restProps} 
  />
</label>
{#if errors}<span class="invalid">{errors}</span>{/if}
The type attribute on input elements must be hard-coded in Svelte, explained here. Especially important for type="number".


+page.svelte


<form method="POST" use:enhance>
  <TextInput
    name="name"
    label="name"
    bind:value={$form.name}
    errors={$errors.name}
    constraints={$constraints.name} 
  />


  <h4>Tags</h4>


  {#each $form.tags as _, i}
    <TextInput
      name="tags"
      label="Name"
      bind:value={$form.tags[i].name}
      errors={$errors.tags?.[i]?.name}
      constraints={$constraints.tags?.name} 
    />
  {/each}
</form>
(Note that you must bind directly to $form.tags with the index, you cannot use the each loop variable, hence the underscore.)


This is a bit better and will certainly help when the components require some styling, but there are still plenty of attributes. Can we do even better?


Things will get a bit advanced from here, so an alternative is to use the Formsnap library, which simplifies componentization a lot.


Using a fieldProxy


You may have used proxy objects for converting an input field string like "2023-04-12" into a Date, but that’s a special usage of proxies. They can actually be used for any part of the form data, to have a store that can modify a part of the $form store. If you want to update just $form.name, for example:


<script lang="ts">
  import { superForm, fieldProxy } from 'sveltekit-superforms/client';


  export let data;


  const { form } = superForm(data.form);


  const name = fieldProxy(form, 'name');
</script>


<div>Name: {$name}</div>
<button on:click={() => ($name = '')}>Clear name</button>
Any updates to $name will reflect in $form.name. Note that this will also taint that field, so if this is not intended, you can use the whole superForm object and add an option:


const theForm = superForm(data.form);
const { form } = theForm;


const name = fieldProxy(theForm, 'name', { taint: false });
A fieldProxy isn’t enough here, however. We’d still have to make proxies for form, errors, and constraints, and then we’re back to the same problem again.


Using a formFieldProxy


The solution is to use a formFieldProxy, which is a helper function for producing the above proxies from a form. To do this, we cannot immediately deconstruct what we need from superForm since formFieldProxy takes the form itself as an argument:


<script lang="ts">
  import type { PageData } from './$types.js';
  import { superForm, formFieldProxy } from 'sveltekit-superforms/client';


  export let data: PageData;


  const form = superForm(data.form);


  const { path, value, errors, constraints } = formFieldProxy(form, 'name');
</script>
But we didn’t want to pass all those proxies, so let’s imagine a component that will handle even the above proxy creation for us.


<TextField {form} field="name" />
How nice would this be? This can actually be pulled off in a typesafe way with a bit of Svelte magic:


<script lang="ts" context="module">
  type T = Record<string, unknown>;
</script>


<script lang="ts" generics="T extends Record<string, unknown>">
  import { 
    formFieldProxy, type SuperForm, type FormPathLeaves 
  } from 'sveltekit-superforms';


  export let form: SuperForm<T>;
  export let field: FormPathLeaves<T>;


  const { value, errors, constraints } = formFieldProxy(form, field);
</script>


<label>
  {field}<br />
  <input
    name={field}
    type="text"
    aria-invalid={$errors ? 'true' : undefined}
    bind:value={$value}
    {...$constraints}
    {...$$restProps} />
</label>
{#if $errors}<span class="invalid">{$errors}</span>{/if}
The Svelte syntax requires Record<string, unknown> to be defined before its used in the generics attribute, so we have to import it in a module context. Now when T is defined (the schema object type), we can use it in the form prop to ensure that only a SuperForm matching the field prop is used.


The FormPathLeaves type prevents using a field that isn’t at the end of the schema (the “leaves” of the schema tree). This means that arrays and objects cannot be used in formFieldProxy. Array-level errors are handled like this.


Type narrowing for paths


Checkboxes don’t bind with bind:value but with bind:checked, which requires a boolean.


Because our component is generic, value returned from formFieldProxy is unknown, but we need a boolean here. Then we can add a type parameter to FormPathLeaves to narrow it down to a specific type, and use the satisfies operator to specify the type:


<script lang="ts" context="module">
  type T = Record<string, unknown>;
</script>


<script lang="ts" generics="T extends Record<string, unknown>">
  import { 
    formFieldProxy, type FormFieldProxy,
    type SuperForm, type FormPathLeaves
  } from 'sveltekit-superforms';


  export let form: SuperForm<T>;
  export let field: FormPathLeaves<T, boolean>;


  const { value, errors, constraints } = formFieldProxy(form, field) satisfies FormFieldProxy<boolean>;
</script>


<input
  name={field}
  type="checkbox"
  class="checkbox"
  bind:checked={$value}
  {...$constraints}
  {...$$restProps} 
/>
This will also narrow the field prop, so only boolean fields in the schema can be selected when using the component.


Checkboxes, especially grouped ones, can be tricky to handle. Read the Svelte tutorial about bind:group, and see the Ice cream example on Stackblitz if you’re having trouble with it.


Using the componentized field in awesome ways


Using this component is now as simple as:


<TextField {form} field="name" />
But to show off some super proxy power, let’s recreate the tags example above with the TextField component:


<form method="POST" use:enhance>
  <TextField name="name" {form} field="name" />


  <h4>Tags</h4>


  {#each $form.tags as _, i}
    <TextField name="tags" {form} field="tags[{i}].name" />
  {/each}
</form>
We can now produce a type-safe text field for any object inside our data, which will update the $form store.


In general, nested data requires the dataType option to be set to 'json', but this example works without it, even without use:enhance, since arrays of primitive values are coerced automatically.


I hope you now feel under your fingers the superpowers that Superforms bring! 💥


Designing a CRUD interface
An excellent use case for Superforms is a backend interface, commonly used as in the acronym CRUD (Create, Read, Update, Delete):


Display an empty form
POST the form, validate the data
Create a new entity with the data (Create)
Fetch the entity (Read)
Display it in a form
POST the form, validate the data
Update the entity with the data (Update)
Delete the entity (Delete)
???
Profit!
Because you can send the data model to the superValidate function and have the form directly populated, it becomes quite easy to implement the above steps.


Getting started


New SvelteKit project


Start from scratch in a new SvelteKit project by executing one of the following commands in your project directory:


npm create svelte@latest
pnpm create svelte@latest
Select Skeleton project and Typescript syntax at the prompts, the rest is up to you. Then add this to <head> in src/app.html for a much nicer visual experience:


<link rel="stylesheet" href="https://unpkg.com/normalize.css@8.0.1/normalize.css" />
<link rel="stylesheet" href="https://unpkg.com/sakura.css/css/sakura.css" />
Start - Creating a test database


When you have the code up and running, we need a user schema, and a mock database for testing. We will use Zod as a validation library, but its schema can easily be converted to others.


src/lib/users.ts


import { z } from 'zod';


// See https://zod.dev/?id=primitives for schema syntax
export const userSchema = z.object({
  id: z.string().regex(/^\d+$/),
  name: z.string().min(2),
  email: z.string().email()
});


type UserDB = z.infer<typeof userSchema>[];


// Let's worry about id collisions later
export const userId = () => String(Math.random()).slice(2);


// A simple user "database"
export const users: UserDB = [
  {
    id: userId(),
    name: 'Important Customer',
    email: 'important@example.com'
  },
  {
    id: userId(),
    name: 'Super Customer',
    email: 'super@example.com'
  }
];
Form vs. database schemas


When starting on the server page, we’ll encounter a thing about validation schemas. Our userSchema is for database integrity, so an id must exist there. But we want to create an entity, and must therefore allow id not to exist when creating users.


Fortunately, Zod makes it quite easy to append a modifier to a field without duplicating the whole schema by extending it:


src/routes/users/[[id]]/+page.server.ts


import { userSchema } from '$lib/users';


const crudSchema = userSchema.extend({
  id: userSchema.shape.id.optional()
});
(Of course, the original userSchema is kept intact.)


With this, Create and Update can now use the same schema, which means that they can share the same user interface. This is a fundamental idea in Superforms: you can pass either empty data or an entity partially matching the schema to superValidate, and it will generate default values for any non-specified fields, ensuring type safety.


Reading a user from the database


Let’s add a load function to the page, using the SvelteKit route parameters to look up the requested user:


src/routes/users/[[id]]/+page.server.ts


import { superValidate, message } from 'sveltekit-superforms';
import { zod } from 'sveltekit-superforms/adapters';
import { error, fail, redirect } from '@sveltejs/kit';
import { users, userId } from '$lib/users';


export const load = async ({ url, params }) => {
  // READ user
  const user = users.find((u) => u.id == params.id);


  if (params.id && !user) throw error(404, 'User not found.');


  // If user is null, default values for the schema will be returned.
  const form = await superValidate(user, zod(crudSchema));
  return { form, users };
};
Some simple logic is used to find the user, and then detect if a 404 should be displayed. At the end, we’re returning form as usual, but also users, so they can be displayed as a list.


(Sometimes, CRUDL is used as an acronym, since listing is also fundamental to data management.)


Now that we have loaded the data, let’s display it in a page component:


src/routes/users/[[id]]/+page.svelte


<script lang="ts">
  import type { PageData } from './$types.js';
  import { page } from '$app/stores';
  import { superForm } from 'sveltekit-superforms';


  export let data: PageData;


  const { form, errors, constraints, enhance, delayed, message } = superForm(
    data.form, {
      resetForm: false
    }
  );
</script>


{#if $message}
  <h3 class:invalid={$page.status >= 400}>{$message}</h3>
{/if}


<h2>{!$form.id ? 'Create' : 'Update'} user</h2>
There are plenty of variables extracted from superForm; refer to the API reference for a complete list. We’ve also setting the resetForm to false, since the data should be kept after editing.


We’ve also prepared a status message, using $page.status to test for success or failure, and we’re using $form.id to display a “Create user” or “Update user” title. Now let’s add the form itself:


src/routes/users/[[id]]/+page.svelte (continued)


<form method="POST" use:enhance>
  <input type="hidden" name="id" bind:value={$form.id} />


  <label>
    Name<br />
    <input
      name="name"
      aria-invalid={$errors.name ? 'true' : undefined}
      bind:value={$form.name}
      {...$constraints.name} />
    {#if $errors.name}<span class="invalid">{$errors.name}</span>{/if}
  </label>


  <label>
    E-mail<br />
    <input
      name="email"
      type="email"
      aria-invalid={$errors.email ? 'true' : undefined}
      bind:value={$form.email}
      {...$constraints.email} />
    {#if $errors.email}<span class="invalid">{$errors.email}</span>{/if}
  </label>


  <button>Submit</button> {#if $delayed}Working...{/if}
</form>


<style>
  .invalid {
    color: red;
  }
</style>
Remember to use SuperDebug if you want to see your form data live!


<script>
  import SuperDebug from 'sveltekit-superforms';
</script>


<SuperDebug data={$form} />
Creating and Updating a user


With this, the form should be ready for creating a user. Let’s add the form action for that:


src/routes/users/[[id]]/+page.server.ts


export const actions = {
  default: async ({ request }) => {
    const form = await superValidate(request, zod(crudSchema));
    if (!form.valid) return fail(400, { form });


    if (!form.data.id) {
      // CREATE user
      const user = { ...form.data, id: userId() };
      users.push(user);


      return message(form, 'User created!');
    } else {
      // UPDATE user
      const index = users.findIndex((u) => u.id == form.data.id);
      if (index == -1) throw error(404, 'User not found.');


      users[index] = { ...form.data, id: form.data.id };
      return message(form, 'User updated!');
    }


    return { form };
  }
};
This is where you should access your database API. In our case, we’re only doing some array manipulations.


With this, we have 3 out of 4 letters of CRUD in about 150 lines of code, half of it HTML!


Deleting a user


To delete a user, we can make use of the HTML button element, which can have a name and a value that will be passed only if that specific button was used to post the form. Add this at the end of the form:


src/routes/users/[[id]]/+page.svelte


{#if $form.id}
  <button
    name="delete"
    on:click={(e) => !confirm('Are you sure?') && e.preventDefault()}
    class="danger">Delete user</button>
{/if}
In the form action, we now use the FormData from the request to check if the delete button was pressed.


We can also add a delayed button in the form to mimick the behavior of a slow network call:


<button name="delay" class="delay">Submit delayed</button>
We shouldn’t use the schema since delete and delayed are not a part of the user, but it’s not a big change:


src/routes/users/[[id]]/+page.server.ts


export const actions: Actions = {
  default: async ({ request }) => {
    const formData = await request.formData();
    const form = await superValidate(formData, zod(crudSchema));


    if (formData.has('delay')) {
      await new Promise((r) => setTimeout(r, 2000));
    }


    if (!form.valid) return fail(400, { form });


    if (!form.data.id) {
      // CREATE user
      const user = { ...form.data, id: userId() };
      users.push(user);


      return message(form, 'User created!');
    } else {
      const index = users.findIndex((u) => u.id == form.data.id);
      if (index == -1) throw error(404, 'User not found.');


      if (formData.has('delete')) {
        // DELETE user
        users.splice(index, 1);
        throw redirect(303, '/users');
      } else {
        // UPDATE user
        users[index] = { ...form.data, id: form.data.id };
        return message(form, 'User updated!');
      }
    }
  }
};
Now all four CRUD operations are complete! An issue, however, is that we have to redirect after deleting to avoid a 404, so we cannot use form.message to show “User deleted”, since the validation data won’t exist after redirecting.


Redirecting with a message is a general problem; for example, maybe we’d like to redirect to the newly created user after it’s been created. Fortunately, there is a solution; the sister library to Superforms handles this. Read more about it here.


Listing the users


The last loose thread is to display a list of the users. It’ll be quite trivial; add this to the top of +page.svelte:


src/routes/+page.svelte


<h3>Users</h3>
<div class="users">
  {#each data.users as user}
    <a href="/users/{user.id}">{user.name}</a>
  {/each}
</div>
And some styling for everything at the end:


<style>
  .invalid {
    color: red;
  }


  .danger {
    background-color: brown;
  }


  .delay {
    background-color: lightblue;
  }


  form {
    display: flex;
    flex-direction: column;
    gap: 1em;
    align-items: flex-start;
    margin-bottom: 2em;
  }


  hr {
    width: 100%;
    margin-block: 2em;
  }


  .users {
    columns: 3 150px;
  }


  .users > * {
    display: block;
    white-space: nowrap;
    overflow-x: hidden;
  }
</style>
That’s it! Thank you for following along, the code is available here on Stackblitz.


Default values
When superValidate encounters a schema field that isn’t optional, and when its supplied data is empty, a default value is returned to the form, to ensure that the type is correct:


Type        Value
string        ""
number        0
boolean        false
Array        []
object        {}
bigint        BigInt(0)
symbol        Symbol()
Changing a default value


You can, of course, set your own default values in the schema, using the default method in Zod, for example. You can even abuse the typing system a bit to handle the classic “agree to terms” checkbox:


const schema = z.object({
  age: z.number().positive().default('' as unknown as number),
  agree: z.literal(true).default(false as true)
});
This looks a bit strange, but will ensure that the age isn’t set to 0 as default (which will hide placeholder text in the input field), and also ensure that the agree checkbox is unchecked as default while also only accepting true (checked) as a value.


Since the default value will not correspond to the type, this will not work when using Zod’s refine on the whole schema. Validation itself is no problem though, form.valid will be false if these values are posted, which should be the main determinant of whether the data is trustworthy.


optional vs. nullable


Fields set to null will take precedence over undefined, so a field that is both nullable and optional will have null as its default value. Otherwise, it’s undefined.


Explicit defaults


Multi-type unions must have an explicit default value, or exactly one of the union types must have one. Enums doesn’t, otherwise it wouldn’t be possible to have a required enum field. If no explicit default, the first enum value will be used.


const schema = z.object({
  either: z.union([z.number(), z.string()]).default(123),
  fish: z.enum(['Salmon', 'Tuna', 'Trout']) // Default will be 'Salmon'
});
If the field is nullable or optional, there’s no need for a default value (but it can still be set).


const schema2 = z.object({
  fish: z.enum(['Salmon', 'Tuna', 'Trout']).nullable()
});


SuperDebug
SuperDebug is a debugging component that gives you colorized and nicely formatted output for any data structure, usually $form returned from superForm. It also shows the current page status in the top right corner.


It’s not limited to the Superforms data, other use cases includes debugging plain objects, promises, stores and more.


Usage


import SuperDebug from 'sveltekit-superforms';
<SuperDebug data={$form} />
Props reference


<SuperDebug
  data={any}
  display={true}
  status={true}
  label=''
  collapsible={false}
  collapsed={false}
  stringTruncate={120}
  raw={false}
  functions={false}
  theme='default'
  ref={HTMLPreElement} 
/>
Prop        Type        Default Value        Description
data        any                Data to be displayed by SuperDebug. The only required prop.
display        boolean        true        Whether to show or hide SuperDebug.
status        boolean        true        Whether to show or hide the HTTP status code of the current page.
label        string        ""        Add a label to SuperDebug, useful when using multiple instances on a page.
collapsible        boolean        false        Makes the component collapsible on a per-route basis.
collapsed        boolean        false        If the component is collapsible, sets it to initially collapsed.
stringTruncate        number        120        Truncate long string field valuns of the data prop. Set to 0 to disable truncating.
raw        boolean        false        Skip promise and store detection when true.
functions        boolean        false        Enables the display of fields of the data prop that are functions.
theme        “default”, “vscode”        "default"        Display theme, which can also be customized with CSS variables.
ref        HTMLPreElement                Reference to the pre element that contains the data.
Examples


Change name here, to see it update in the SuperDebug instances: 
Gaspar Soiaga
Default output


<SuperDebug data={$form} />
200
{
  name: "Gaspar Soiaga",
  email: "wendat@example.com",
  birth: 1649-01-01T00:00:00.000Z
}
With a label


A label is useful when using multiple instance of SuperDebug.


<SuperDebug label="Useful label" data={$form} />
Useful label
200
{
  name: "Gaspar Soiaga",
  email: "wendat@example.com",
  birth: 1649-01-01T00:00:00.000Z
}
With label, without status


<SuperDebug label="Sample User" status={false} data={$form} />
Sample User
{
  name: "Gaspar Soiaga",
  email: "wendat@example.com",
  birth: 1649-01-01T00:00:00.000Z
}
Without label and status


<SuperDebug data={$form} status={false} />
{
  name: "Gaspar Soiaga",
  email: "wendat@example.com",
  birth: 1649-01-01T00:00:00.000Z
}
Display only in dev mode


<script lang="ts">
  import { dev } from '$app/environment';
</script>


<SuperDebug data={$form} display={dev} />
Promise support


To see this in action, scroll to the product data below and hit refresh.


// +page.ts
export const load = (async ({ fetch }) => {
  const promiseProduct = fetch('https://dummyjson.com/products/1')
    .then(response => response.json())


  return { promiseProduct }
})
<SuperDebug label="Dummyjson product" data={data.promiseProduct} />
Dummyjson product
200
{
  id: 1,
  title: "iPhone 9",
  description: "An apple mobile which is nothing like apple",
  price: 549,
  discountPercentage: 12.96,
  rating: 4.69,
  stock: 94,
  brand: "Apple",
  category: "smartphones",
  thumbnail: "https://cdn.dummyjson.com/product-images/1/thumbnail.jpg",
  images: [
    "https://cdn.dummyjson.com/product-images/1/1.jpg",
    "https://cdn.dummyjson.com/product-images/1/2.jpg",
    "https://cdn.dummyjson.com/product-images/1/3.jpg",
    "https://cdn.dummyjson.com/product-images/1/4.jpg",
    "https://cdn.dummyjson.com/product-images/1/thumbnail.jpg"
  ]
}
Rejected promise


// +page.ts
export const load = (async ({ fetch }) => {
  const rejected = Promise.reject(throw new Error('Broken promise'))
  return { rejected }
})
<SuperDebug data={rejected} />
200
Rejected: Error: Broken promise
Composing debug data


If you want to debug multiple stores/objects in the same instance.


<SuperDebug data={{$form, $errors}} />
200
{
  $form: {
    name: "Gaspar Soiaga",
    email: "wendat@example.com",
    birth: 1649-01-01T00:00:00.000Z
  },
  $errors: {
    email: [
      "Cannot use example.com as email."
    ]
  }
}
Displaying files


SuperDebug displays File and FileList objects as well:


<SuperDebug data={$form} />
200
{
  file: {
    name: "example.txt",
    size: 120,
    type: "text/plain",
    lastModified: 2024-02-27T14:35:27.497Z
  }
}
SuperDebug loves stores


You can pass a store directly to SuperDebug:


<SuperDebug data={form} />
200
{
  name: "Gaspar Soiaga",
  email: "wendat@example.com",
  birth: 1649-01-01T00:00:00.000Z
}
Custom styling


<SuperDebug 
  data={$form} 
  theme="vscode" 
  --sd-code-date="lightgreen" 
/>
200
{
  name: "Gaspar Soiaga",
  email: "wendat@example.com",
  birth: 1649-01-01T00:00:00.000Z
}
CSS variables available for customization




Display variables
--sd-bg-color
--sd-label-color
--sd-promise-loading-color
--sd-promise-rejected-color
--sd-code-default
--sd-info
--sd-success
--sd-redirect
--sd-error
--sd-code-key
--sd-code-string
--sd-code-date
--sd-code-boolean
--sd-code-number
--sd-code-bigint
--sd-code-null
--sd-code-nan
--sd-code-undefined
--sd-code-function
--sd-code-symbol
--sd-code-error
--sd-sb-width
--sd-sb-height
--sd-sb-track-color
--sd-sb-track-color-focus
--sd-sb-thumb-color
--sd-sb-thumb-color-focus
Note that styling the component produces the side-effect described in the Svelte docs.


Page data


Debugging Svelte’s $page data, when the going gets tough. Since it can contain a lot of data, using the collapsible prop is convenient.


<script lang="ts">
  import { page } from '$app/stores';
</script>


<SuperDebug label="$page data" data={$page} collapsible />
$page data
200
{
  error: null,
  params: {},
  route: {
    id: "/super-debug"
  },
  state: {},
  status: 200,
  url: "https://superforms.rocks/super-debug",
  form: null,
  data: {}
}


FAQ
I see the data in $form, but it’s not posted to the server?


The most common mistake is to forget the name attribute on the input field. If you’re not using dataType: 'json' (see nested data), the form is treated as a normal HTML form, which requires a name attribute for posting the form data.


How can I return additional data together with the form?


You’re not limited to just return { form } in load functions and form actions; you can return anything else together with the form variables (which can also be called anything you’d like).


From a load function


export const load = (async ({ locals }) => {
  const loginForm = await superValidate(zod(loginSchema));
  const userName = locals.currentUser.name;
  
  return { loginForm, userName };
})
It can then be accessed in PageData in +page.svelte:


<script lang="ts">
  import type { PageData } from './$types.js';
  export let data: PageData;


  const { form, errors, enhance } = superForm(data.loginForm);
</script>


<p>Currently logged in as {data.userName}</p>
From a form action


Returning extra data from a form action is most convenient with a status message. But you can also return it directly, in which case it can be accessed in ActionData:


export const actions = {
  default: async ({ request, locals }) => {
    const form = await superValidate(request, zod(schema));


    if (!form.valid) return fail(400, { form });


    // TODO: Do something with the validated data


    const userName = locals.currentUser.name;
    return { form, userName };
  }
};
<script lang="ts">
  import type { PageData, ActionData } from './$types.js';
  import { superForm } from 'sveltekit-superforms/client'


  export let data: PageData;
  export let form: ActionData;


  // Need to rename form here, since it's used by ActionData.
  const { form: loginForm, errors, enhance } = superForm(data.loginForm);
</script>


{#if form?.userName}
  <p>Currently logged in as {form.userName}</p>
{/if}
Using a status message instead avoids having to import ActionData and rename the form store.


What about the other way around, posting additional data to the server?


You can add additional input fields to the form that aren’t part of the schema, including files (see the next question), to send extra data to the server. They can then be accessed with request.formData() in the form action:


export const actions = {
  default: async ({ request }) => {
    const formData = await request.formData();
    const form = await superValidate(formData, zod(schema));


    if (!form.valid) return fail(400, { form });


    if (formData.has('extra')) {
      // Do something with the extra data
    }


    return { form };
  }
};
You can also add form data programmatically in the onSubmit event:


const { form, errors, enhance } = superForm(data.loginForm, {
  onSubmit({ formData }) {
    formData.set('extra', 'value')
  }
})
The onSubmit event is also a good place to modify $form, in case you’re using nested data with dataType: 'json'.


How to handle file uploads?


From version 2, file uploads are handled by Superforms. Read all about it on the file uploads page.


Can I use endpoints instead of form actions?


Yes, there is a helper function for constructing an ActionResult that can be returned from SvelteKit endpoints. See the API reference for more information.


Can I post to an external API?


If the API doesn’t return an ActionResult with the form data, you cannot post to it directly. Instead you can use the SPA mode of Superforms and call the API with fetch or similar in the onUpdate event.


How to submit the form programmatically?


Use the requestSubmit method on the form element to submit it manually.


Can a form be factored out into a separate component?


Yes - the answer has its own article page here.


I’m getting JSON.parse errors as response when submitting a form, why?


This is related to the previous question. You must always return an ActionResult as a response to a form submission, either through a form action, where it’s done automatically, or by constructing one with the actionResult helper.


If for some reason a html page or plain text is returned, for example when a proxy server fails to handle the request and returns its own error page, the parsing of the result will fail with the slightly cryptic JSON error message.


Why am I’m getting TypeError: The body has already been consumed?


This happens if you access the form data of the request several times, which could happen when calling superValidate multiple times during the same request.


To fix that problem, extract the formData before calling superValidate, and use that as an argument instead of request or event:


export const actions = {
  default: async ({ request }) => {
    const formData = await request.formData();


    const form = await superValidate(formData, zod(schema));
    const form2 = await superValidate(formData, zod(anotherSchema));


    // Business as usual
  }
};
Why does the form get tainted without any changes, when I use a select element?


If the schema field for the select menu doesn’t have an empty string as default value, for example when it’s optional, and you have an empty first option, like a “Please choose item” text, the field will be set to the empty string, tainting the form.


It can be fixed by setting the option and the default schema value to an empty string, even if it’s not its proper type. See this section for an example.


How to customize error messages directly in the validation schema?


You can add them as parameters to most schema methods. Here’s an example.


Can you use Superforms without any data, for example with a delete button on each row in a table?


That’s possible with an empty schema, or using the $formId store with the button to set the form id dynamically. See this Stackblitz repo for an example.


I want to reuse common options, how to do that easily?


When you start to configure the library to suit your stack, you can create an object with default options that you will refer to instead of superForm:


import { superForm } from 'sveltekit-superforms';


export type Message = {
  status: 'success' | 'error' | 'warning';
  text: string;
};


// If no strongly type message is needed, leave out the M type parameter
export function mySuperForm<T extends Record<string, unknown>, M = Message>(
  ...params: Parameters<typeof superForm<T, M>>
) {
  return superForm<T, M>(params[0], {
    // Your defaults here
    errorSelector: '.has-error',
    delayMs: 300,
    ...params[1]
  });
}


Flash messages
Status messages are useful, but redirects will cause them to be lost, because they need to be returned in { form }, usually as a response from a POST request.


Since it’s common to redirect after a successful post, especially in backend interfaces, the form.message property isn’t a general solution for displaying status messages.


The sister library to Superforms is called sveltekit-flash-message, a useful addon that handles temporary messages sent with redirects. Note that at least version 1.0 is required!


Usage


The library works together with Superforms without any extra configuration, usually you can replace the Superforms status messages with the flash message, and that will work very well.


But if you have some special use case where you need to integrate the flash message more closely with a form, you can do that by importing its module when calling superForm:


import * as flashModule from 'sveltekit-flash-message/client';


const { form, errors, enhance } = superForm(data.form, {
  flashMessage: {
    module: flashModule,
    onError?: ({ result, flashMessage }) => {
      // Error handling for the flash message:
      // - result is the ActionResult
      // - flashMessage is the flash store (not the status message store)
      const errorMessage = result.error.message
      flashMessage.set(/* Your flash message type */);
    }
  },
  syncFlashMessage: false
}
Then the following options are available:


syncFlashMessage


If set to true, when form.message is updated, the flash message will be synchronized with it, including honoring the clearOnSubmit option.


It’s important that the flash and form message types are matching, in this case. See this section on how to make the form message strongly typed.


flashMessage.onError


If a form error occurs, which happens when error(...) is called in a form action (and use:enhance is added to the form), the flashMessage.onError callback can be used to transform it into your flash message type, so you can display the error at the flash message instead of in form.message.


Formsnap


As you may have seen on the componentization page, quite a bit of boilerplate can add up for a form, and then we haven’t even touched on the subject of accessibility.


Fortunately, the UI-component guru Hunter Johnston, aka @huntabyte, has done the community a great service with his library Formsnap! It not only simplifies how to put your forms into components, but also adds top-class accessibility with no effort.


This is the style you can expect when using Formsnap, compared to manually putting attributes on individual form fields:


<form method="POST" use:enhance>
  <Field {form} name="name">
    <Control let:attrs>
      <Label>Name</Label>
      <input {...attrs} bind:value={$formData.name} />
    </Control>
    <Description>Be sure to use your real name.</Description>
    <FieldErrors />
  </Field>
  <Field {form} name="email">
    <Control let:attrs>
      <Label>Email</Label>
      <input {...attrs} type="email" bind:value={$formData.email} />
    </Control>
    <Description>It's preferred that you use your company email.</Description>
    <FieldErrors />
  </Field>
  <Field {form} name="password">
    <Control let:attrs>
      <Label>Password</Label>
      <input {...attrs} type="password" bind:value={$formData.password} />
    </Control>
    <Description>Ensure the password is at least 10 characters.</Description>
    <FieldErrors />
  </Field>
</form>
If it suits you, please check out the Formsnap library, it is really nice! 💥




FORMSNAP DOCS




OVERVIEW


Introduction
What is this?


Formsnap takes the already incredible sveltekit-superforms (winner of Svelte Hack 2023 for best library), made by the brilliant Andreas Söderlund and wraps it with components that make it simpler to use while making your forms accessible by default.


The Same Form, Two Ways
To showcase the value provided by Formsnap, let's take a look at a simple sign up form using only Superforms, and then using Superforms with Formsnap.


Superforms Only
+page.svelte
<script lang="ts">
        import type { PageData } from "./$types";
        import { superForm } from "sveltekit-superforms";
        import { zodClient } from "sveltekit-superforms/adapters";
        import { signupFormSchema } from "./schema";
        export let data: PageData;
 
        const { form, errors, enhance, constraints } = superForm(data.form, {
                validators: zodClient(signupFormSchema),
        });
</script>
 
<form method="POST" use:enhance>
        <label for="name">Name</label>
        <input
                id="name"
                name="name"
                aria-describedby={$errors.name ? "name-error name-desc" : "name-desc"}
                aria-invalid={$errors.name ? "true" : undefined}
                aria-required={$constraints.name?.required ? "true" : undefined}
                bind:value={$form.name}
        />
        <span id="name-desc">Be sure to use your real name.</span>
        <span id="name-error" aria-live="assertive">
                {#if $errors.name.length}
                        {#each $errors.name as err}
                                {err}
                        {/each}
                {/if}
        </span>
        <label for="email">Email</label>
        <input
                id="email"
                name="email"
                type="email"
                aria-describedby={$errors.email ? "email-error email-desc" : "email-desc"}
                aria-invalid={$errors.email ? "true" : undefined}
                aria-required={$constraints.email?.required ? "true" : undefined}
                bind:value={$form.email}
        />
        <span id="email-desc">It's preferred that you use your company email.</span>
        <span id="email-error" aria-live="assertive">
                {#if $errors.email.length}
                        {#each $errors.email as err}
                                {err}
                        {/each}
                {/if}
        </span>
        <label for="password">Password</label>
        <input
                id="password"
                name="password"
                type="password"
                aria-describedby={$errors.password
                        ? "password-error password-desc"
                        : "password-desc"}
                aria-invalid={$errors.password ? "true" : undefined}
                aria-required={$constraints.password?.required ? "true" : undefined}
                bind:value={$form.password}
        />
        <span id="password-desc">Ensure the password is at least 10 characters.</span>
        <span id="password-error" aria-live="assertive">
                {#if $errors.password.length}
                        {#each $errors.password as err}
                                {err}
                        {/each}
                {/if}
        </span>
        <button>Submit</button>
</form>
Copy
That's quite a bit of code required to get a simple, accessible form up and running. We can't move as quickly as we'd like to, it's not very DRY, and is ripe for copy-paste errors.


All is not lost though, as the whole idea behind Formsnap is to make this process simpler, without sacrificing the flexibility that Superforms provides.


Superforms + Formsnap
+page.svelte
<script lang="ts">
        import { Field, Control, Label, FieldErrors, Description } from "formsnap";
        import type { PageData } from "./$types";
        import { signupFormSchema } from "./schema.ts";
        import { zodClient } from "sveltekit-superforms/adapters";
        import { superForm } from "sveltekit-superforms";
        export let data: PageData;
 
        const form = superForm(data.form, {
                validators: zodClient(signupFormSchema),
        });
        const { form: formData, enhance } = form;
</script>
 
<form method="POST" use:enhance>
        <Field {form} name="name">
                <Control let:attrs>
                        <Label>Name</Label>
                        <input {...attrs} bind:value={$formData.name} />
                </Control>
                <Description>Be sure to use your real name.</Description>
                <FieldErrors />
        </Field>
        <Field {form} name="email">
                <Control let:attrs>
                        <Label>Email</Label>
                        <input {...attrs} type="email" bind:value={$formData.email} />
                </Control>
                <Description>It's preferred that you use your company email.</Description>
                <FieldErrors />
        </Field>
        <Field {form} name="password">
                <Control let:attrs>
                        <Label>Password</Label>
                        <input {...attrs} type="password" bind:value={$formData.password} />
                </Control>
                <Description>Ensure the password is at least 10 characters.</Description>
                <FieldErrors />
        </Field>
</form>
Copy
That's it! We just condensed a bunch of code, while retaining the same functionality.


Next Steps
To get started using Formsnap, head over to the Quick start section of the docs, where you'll learn how to install and use the library.


Quick start
Learn how to take off with Formsnap by building a settings form.


Installation
Since Formsnap is built on top of Superforms, you'll need to install it as well as a schema validation library of your choice. We'll use Zod.


npm install formsnap sveltekit-superforms zod
Copy
Tutorial: Build a settings form
Before diving into this tutorial, it's important to be confident with Superforms, as Formsnap is built on top of it and uses the same APIs.


Define a Zod schema
This schema will represent the shape of our form data. It's used to validate the form data on the client (optional) and server, along with some other useful things.


src/routes/settings/schema.ts
import { z } from "zod";
 
export const themes = ["light", "dark"] as const;
export const languages = ["en", "es", "fr"] as const;
export const allergies = ["peanuts", "dairy", "gluten", "soy", "shellfish"] as const;
 
export const schema = z.object({
        email: z.string().email("Please enter a valid email."),
        bio: z.string().optional(),
        theme: z.enum(themes).default("light"),
        language: z.enum(languages).default("en"),
        marketingEmails: z.boolean().default(true),
        allergies: z.array(z.enum(allergies)),
});
Copy
Looking at the schema above, we know we'll need a few different input types to represent the different data types. Here's how we'll map the schema to input types:


email -> <input type="email">
bio -> <textarea>
theme -> <input type="radio">
language -> <select>
marketingEmails -> <input type="checkbox>
allergies -> <input type="checkbox"> (group/multiple)
Of course, there are other ways to represent the data, but this is the approach we'll take for this tutorial.


Return the form from a load function
In Superforms fashion, we'll return the form from a load function to seamlessly merge our PageData and ActionData.


src/routes/settings/+page.server.ts
import type { PageServerLoad } from "./$types";
import { schema } from "./schema";
import { superValidate } from "sveltekit-superforms";
import { zod } from "sveltekit-superforms/adapters";
 
export const load: PageServerLoad = async () => {
        return {
                form: await superValidate(zod(schema)),
        };
};
Copy
Setup the form in the page component
Now that we have our form in the PageData object, we can use it, along with the schema we defined earlier, to setup the form in our page component.


src/routes/settings/+page.svelte
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import { Field } from "formsnap";
        import { zodClient } from "sveltekit-superforms/adapters";
        import type { PageData } from "./$types.js";
        import { allergies, schema, themes } from "./schema.js";
        import SuperDebug from "sveltekit-superforms";
 
        export let data: PageData;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
        const { form: formData, enhance } = form;
</script>
 
<form method="POST" use:enhance>
        <!-- ... -->
</form>
<SuperDebug data={$formData} />
Copy
We'll initialize the super form using superForm and pass in the form from the PageData. We'll also enable client-side validation by passing the validators option. Then, we'll setup the form using the enhance function, which will progressively enhance the form with client-side validation and other features.


Constructing a form field
You can think of form fields as the building blocks of your form. Each property of the schema will have a corresponding form field, which will be responsible for displaying the error messages and description.


We'll start with the email field and work our way down.


src/routes/settings/+page.svelte
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import { zodClient } from "sveltekit-superforms/adapters";
        import type { PageData } from "./$types.js";
        import { allergies, schema, themes } from "./schema.js";
        import SuperDebug from "sveltekit-superforms";
 
        export let data: PageData;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
        const { form: formData, enhance } = form;
</script>
 
<form method="POST" use:enhance>
        <Field {form} name="email">
                <!-- ... -->
        </Field>
</form>
<SuperDebug data={$formData} />
Copy
We pass the form and name to the Field component, which will be used to setup the context for the field. The name is typed to the keys of the schema, so it's type-safe.


Now let's add the remaining parts of the field:


src/routes/settings/+page.svelte
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import { Field, Control, Label, Description, FieldErrors } from "formsnap";
        import { zodClient } from "sveltekit-superforms/adapters";
        import type { PageData } from "./$types.js";
        import { allergies, schema, themes } from "./schema.js";
        import SuperDebug from "sveltekit-superforms";
 
        export let data: PageData;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
        const { form: formData, enhance } = form;
</script>
 
<form method="POST" use:enhance>
        <Field {form} name="email">
                <Control let:attrs>
                        <Label>Email</Label>
                        <input {...attrs} type="email" bind:value={$formData.email} />
                </Control>
                <Description>Use your company email if you have one.</Description>
                <FieldErrors />
        </Field>
</form>
<SuperDebug data={$formData} />
Copy
We've first added the Control component. Controls are used to represent a form control and its label. They keep the control and label in sync via the attrs slot prop, which is spread onto the control. Inside the Control, we've added the Label component, which will automatically associate itself with the control the attrs are spread onto. We've also added the control itself, which is an input that we're binding to the email property of the form data.


The Description component is optional, but it's useful for providing additional context to the user about the field. It'll be synced with the aria-describedby attribute on the input, so it's accessible to screen readers.


The FieldErrors component is used to display validation errors to the user. It also is synced with the aria-describedby attribute on the input, which can receive multiple IDs, so that screen readers are able to read the error messages in addition to the description.


And that's really all it takes to setup a form field. Let's continue on with the rest of the fields.


Add remaining form fields
src/routes/settings/+page.svelte
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import {
                Field,
                Control,
                Label,
                Description,
                FieldErrors,
                Fieldset,
                Legend,
        } from "formsnap";
        import { zodClient } from "sveltekit-superforms/adapters";
        import type { PageData } from "./$types.js";
        import { allergies, schema, themes } from "./schema.js";
        import SuperDebug from "sveltekit-superforms";
 
        export let data: PageData;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
        const { form: formData, enhance } = form;
</script>
 
<form use:enhance class="mx-auto flex max-w-md flex-col" method="POST">
        <Field {form} name="email">
                <Control let:attrs>
                        <Label>Email</Label>
                        <input {...attrs} type="email" bind:value={$formData.email} />
                </Control>
                <Description>Company email is preferred</Description>
                <FieldErrors />
        </Field>
        <Field {form} name="bio">
                <Control let:attrs>
                        <Label>Bio</Label>
                        <textarea {...attrs} bind:value={$formData.bio} />
                </Control>
                <Description>Tell us a bit about yourself.</Description>
                <FieldErrors />
        </Field>
        <Field {form} name="language">
                <Control let:attrs>
                        <Label>Language</Label>
                        <select {...attrs} bind:value={$formData.language}>
                                <option value="fr">French</option>
                                <option value="es">Spanish</option>
                                <option value="en">English</option>
                        </select>
                </Control>
                <Description>Help us address you properly.</Description>
                <FieldErrors />
        </Field>
        <Fieldset {form} name="theme">
                <Legend>Select your theme</Legend>
                {#each themes as theme}
                        <Control let:attrs>
                                <Label>{theme}</Label>
                                <input {...attrs} type="radio" value={theme} bind:group={$formData.theme} />
                        </Control>
                {/each}
                <Description>We prefer dark mode, but the choice is yours.</Description>
                <FieldErrors />
        </Fieldset>
        <Field {form} name="marketingEmails">
                <Control let:attrs>
                        <input {...attrs} type="checkbox" bind:checked={$formData.marketingEmails} />
                        <Label>I want to receive marketing emails</Label>
                </Control>
                <Description>Stay up to date with our latest news and offers.</Description>
                <FieldErrors />
        </Field>
        <Fieldset {form} name="allergies">
                <Legend>Food allergies</Legend>
                {#each allergies as allergy}
                        <Control let:attrs>
                                <input
                                        {...attrs}
                                        type="checkbox"
                                        bind:group={$formData.allergies}
                                        value={allergy}
                                />
                                <Label>{allergy}</Label>
                        </Control>
                {/each}
                <Description>When we provide lunch, we'll accommodate your needs.</Description>
                <FieldErrors />
        </Fieldset>
        <button>Submit</button>
</form>
<SuperDebug data={$formData} />
Copy
You may have noticed for the allergies and theme fields, we used the Fieldset and Legend components. These are used to group related fields together and provide a title for the group, which is great for accessibility and organization. Additionally, we only use a single FieldError and Description component for the entire group, and use an Control for each field in the group to associate the label with the control.


And that's it! You've now successfully built a settings form with Formsnap!


Next Steps
Now that you've built your first form, you're ready to start building more complex forms with Formsnap & Superforms. Be sure to check out the rest of the documentation to learn more about the different components and APIs available to you.


Styling
Easily style the various parts of your forms.


Formsnap doesn't ship with any styles by default, but it does provide a number of ways to style the various parts of your form. You can use the class prop to apply classes to the various components, or you can use the data attributes to style the components using CSS.


Data Attributes
Data attributes are applied to the various parts of your form so that you can easily style them using those attributes as selectors on a parent element or at the global level.


Attribute        Description
data-fs-error        Applied to all the formsnap elements within a field if the field has a validation error. Using this attribute, you can customize the appearance of the input, label, etc. when the field has a validation error.
data-fs-control        Applied to the form control element used within a Control context.
data-fs-label        Applied to the <label> element rendered by the Label component.
data-fs-field-errors        Applied to the FieldErrors container <div> element.
data-fs-field-error        Applied to the individually rendered <div> elements for each of the errors in the FieldErrors component.
data-fs-description        Applied to the <div> element rendered by the Description component.
data-fs-fieldset        Applied to the <fieldset> element rendered by the Fieldset component.
data-fs-legend        Applied to the <legend> element rendered by the Legend component.
Here's an example of how you might use these data attributes to style the various parts of your form:


app.pcss
[data-fs-error] {
        color: red;
}
 
[data-fs-control] {
        border: 1px solid #ccc;
}
 
/* ... */
Copy
CSS Frameworks
If you're using a CSS framework like TailwindCSS or UnoCSS, you can simply pass the class prop to the various components that render HTML elements under the hood. For example:


<script lang="ts">
        import { Label } from "formsnap";
</script>
 
<form>
        <!-- ... -->
        <Label class="text-black hover:text-orange-500">First Name</Label>
        <!-- ... -->
</form>




COMPONENTS


Components


Field
Provides the necessary context for a form field.


The Field component provides the necessary context for its children to react to changes in the form state, as well as provides necessary information about the field, such as the ids needed for aria attributes, and a lot more.


Each Field creates its own context, and the children of the field only access the immediate parent's context.


Props
The Field component doesn't render an element, it strictly provides context.


export type FieldProps<T extends Record<string, unknown>, U extends FormPath<T>> = {
        /** The form object returned from calling `superForm` in your component. */
        form: SuperForm<T>;
 
        /** The path to the field in the form object. */
        name: U;
};
Copy
Slot Props
The following slot props are provided for convenience and ease of composition when using the Field component.


type SlotProps<T extends Record<string, unknown>, U extends FormPath<T>> = {
        /** The value of the value store of the field. */
        value: T[U];
 
        /** The value of the errors store for the field. */
        errors: string[] | undefined;
 
        /** The constraints for the field. */
        constraints: Record<string, unknown>;
 
        /** Whether the field is tainted or not. */
        tainted: boolean;
};
Copy
Composition
Since the Field component doesn't render any HTML elements, it's a common practice to create a wrapper component around it to have consistent styling and behavior across your forms.


For example, you may always want to render the FieldErrors component for every field. Instead of manually including it every time, you can create a wrapper <CustomField /> component that includes it automatically.


To maintain the type safety of the component, we'll need to use some generics, which eslint sometimes complains about, so if you see a warning, it's likely a false positive and you can ignore it.


CustomField.svelte
<script lang="ts" context="module">
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        import type { FormPath } from "sveltekit-superforms";
 
        // the form object
        type T = Record<string, unknown>;
        // the path/name of the field in the form object
        type U = unknown;
</script>
 
<script
        lang="ts"
        generics="T extends Record<string, unknown>, U extends FormPath<T>"
>
        import { Field, type FieldProps, FieldErrors } from "formsnap";
        import type { SuperForm } from "sveltekit-superforms";
 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        type $$Props = FieldProps<T, U>;
 
        export let form: SuperForm<T>;
        export let name: U;
</script>
 
<!-- passing the slot props down are optional -->
<Field {form} {name} let:value let:errors let:tainted let:contraints>
        <slot {value} {errors} {tainted} {constraints} />
        <FieldErrors />
</Field>


Components


Fieldset
Groups related form controls or fields and extends the Field component.


The Fieldset component is used to follow the W3C Grouping Controls recommendation for associating related form controls. It renders a <fieldset> element and should always be used in conjunction with the Legend component to provide a title for the group.


This component automatically includes the Field component, so you don't need to worry about wrapping it yourself, just be sure to pass the form and name props to the Fieldset as you would with the Field component.


When to use a fieldset
Radio Groups
When you have a group of radio buttons related to a single field, you should use a Fieldset to group them together.


<Fieldset {form} name="theme">
        <Legend>Select your theme</Legend>
        {#each themes as theme}
                <Control let:attrs>
                        <input {...attrs} type="radio" bind:group={$formData.theme} value={theme} />
                        <Label>{theme}</Label>
                </Control>
        {/each}
        <Description>
                Help us understand your preferences by selecting a theme.
        </Description>
        <FieldErrors />
</Fieldset>
Copy
Checkbox Groups
When you have a group of checkboxes related to a single field, typically used for multiple selections, you should use a Fieldset to group them together.


<Fieldset {form} name="allergies">
        <Legend>Any food allergies?</Legend>
        {#each allergies as allergy}
                <Control let:attrs>
                        <input
                                {...attrs}
                                type="checkbox"
                                bind:group={$formData.allergies}
                                value={allergy}
                        />
                        <Label>{allergy}</Label>
                </Control>
        {/each}
        <Description>We'll make sure to accommodate your dietary needs.</Description>
        <FieldErrors />
</Fieldset>
Copy
Grouped Form Sections
When you have a large form with multiple sections containing related fields, such as a "Billing Address" and a "Shipping Address", you should use a <fieldset> to group the related fields together. You won't use the Fieldset component directly in this case, since it doesn't represent a field on the form.


<form>
        <fieldset>
                <legend>Billing Address</legend>
                <!-- ... billing address fields -->
        </fieldset>
        <fieldset>
                <legend>Shipping Address</legend>
                <!-- ... shipping address fields -->
        </fieldset>
</form>
Copy
Props
The Fieldset component renders a <fieldset> element and accepts the following props:


export type FieldsetProps<
        T extends Record<string, unknown>,
        U extends FormPath<T>,
> = {
        /**
         * The form object returned from calling `superForm` in your component.
         */
        form: SuperForm<T>;
 
        /**
         * The path to the field in the form object.
         */
        name: U;
 
        /**
         * If `true`, Formsnap won't render the default `div` element
         * and will expect you to spread the `groupAttrs` slot prop into
         * a custom label element/component of your choosing.
         *
         * @see https://formsnap.dev/docs/composition/aschild
         * @defaultValue `false`
         */
        asChild?: boolean;
 
        /**
         * You can bind to this prop to receive a reference to the
         * underling HTML element rendered for the group.
         */
        el?: HTMLFieldSetElement;
} & Omit<HTMLFieldsetAttributes, "form">;
Copy
Slot Props
The Fieldset component provides a single slot prop, fieldsetAttrs, which is only necessary when using the asChild prop.


type SlotProps = {
        fieldsetAttrs: FieldsetAttrs;
};
Copy
Attributes
The following attributes are automatically applied to the <fieldset> element rendered by the Fieldset component. This is also the shape of the fieldsetAttrs slot prop when using the asChild prop.


export type FieldsetAttrs = {
        /** Used for selection during styling or otherwise */
        "data-fs-fieldset": string;
 
        /** Present when a validation error exists on the field. */
        "data-fs-error": string | undefined;
 
        /* Any additional props provided to `<Form.Fieldset />` */
        [key: string]: any;
};


Components


ElementField
Provides the necessary context for a form field that represents a single element in an array.


The ElementField component is used to treat each element of an array as a separate form field. It's useful when you have a dynamic list of items that you want to treat as separate fields in your form.


ElementFields should be used within the context of a Field or Fieldset component. ElementFields create their own context to scope the errors and other states of the field.


Usage
Here's an example of how you might use the ElementField component to create a dynamic list of URLs in a form.


<script lang="ts">
        import {
                ElementField,
                FieldErrors,
                Control,
                Label,
                Fieldset,
                Description,
        } from "formsnap";
        import { superForm } from "sveltekit-superforms";
        import { zodClient } from "sveltekit-superforms/adapters";
        import { z } from "zod";
 
        const schema = z.object({
                urls: z.array(z.string().url()).min(2).default(["", ""]),
        });
 
        export let data;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
 
        const { form: formData, enhance } = form;
</script>
 
<form use:enhance method="POST">
        <Fieldset {form} name="urls">
                <Legend>Enter your URLS</Legend>
                {#each $formData.urls as _, i}
                        <ElementField {form} name="urls[{i}]">
                                <Control let:attrs>
                                        <Input type="url" bind:value={$formData.urls[i]} {...attrs} />
                                </Control>
                                <FieldErrors />
                        </ElementField>
                {/each}
                <Description>Your URLs will be displayed on your public profile.</Description>
                <FieldErrors />
        </Fieldset>
        <button type="submit">Submit</button>
</form>
Copy
We're able to display errors for each element of the array, as well as array-level errors for the entire fieldset.


Check out the Dynamic Fields recipe for more advanced usage of the ElementField component.


Props
The ElementField component doesn't render an element, it strictly provides context for its children. It accepts the following props:


export type ElementFieldProps<
        T extends Record<string, unknown>,
        U extends FormPathLeaves<T>,
> = {
        /**
         * The form object returned from calling `superForm` in your component.
         */
        form: SuperForm<T>;
 
        /**
         * The path to the field in the form object.
         */
        name: U;
};
Copy
Slot Props
The following slot props are provided for convenience and ease of composition when using the ElementField component.


type SlotProps<T extends Record<string, unknown>, U extends FormPath<T>> = {
        /** The value of the value store of the field. */
        value: T[U];
 
        /** The value of the errors store for the field. */
        errors: string[] | undefined;
 
        /** The constraints for the field. */
        constraints: Record<string, unknown>;
 
        /** Whether the field is tainted or not. */
        tainted: boolean;
};
Copy
Composition
Since the ElementField component doesn't render any HTML elements, it's common practice to create a wrapper component around it to have consistent styling and behavior across your forms.


For example, you may always want to render the FieldErrors component for every field. Rather than manually including it each time, you can create a wrapper <CustomElementField /> component that includes it automatically.


To maintain the type safety of the component, we'll need to use some generics, which eslint sometimes complains about, so if you see a warning, it's likely a false positive and you can ignore it.


CustomElementField.svelte
<script lang="ts" context="module">
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        import type { FormPathArrays, FormPathLeaves } from "sveltekit-superforms";
        type T = Record<string, unknown>;
        type U = unknown;
</script>
 
<script
        lang="ts"
        generics="T extends Record<string, unknown>, U extends FormPathLeaves<T>"
>
        import { ElementField, type ElementFieldProps, FieldErrors } from "formsnap";
        import type { SuperForm } from "sveltekit-superforms";
 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        type $$Props = ElementFieldProps<T, U>;
 
        export let form: SuperForm<T>;
        export let name: U;
</script>
 
<!-- passing the slot props down are optional -->
<ElementField {form} {name} let:value let:errors let:tainted let:contraints>
        <slot {value} {errors} {tainted} {constraints} />
        <FieldErrors />
</ElementField>
Components


FieldErrors
The container for validation errors for a Field, Fieldset, or ElementField.


The FieldErrors component renders the following structure by default (attributes omitted for brevity):


<div>
        <slot errors={$errors}>
                {#each $errors as error}
                        <div>{error}</div>
                {/each}
        </slot>
</div>
Copy
Notice that we're populating the fallback slot, so if you don't provide a slot for the FieldErrors component, it will render a <div> element for each error in the errors array.


The errors are the errors for the Field, Fieldset, or ElementField that the FieldErrors component is associated with and must be used within the context of one of those components.


The errors container is automatically linked to the control of the field using the aria-describedby attribute when errors are present.


Usage
Basic Usage
By default, the FieldErrors component will render a <div> element with the errors for the field it is associated with.


<Field {form} name="name">
        <Control let:attrs>
                <Label>Name</Label>
                <input type="text" {...attrs} />
        </Control>
        <FieldErrors />
</Field>
Copy
Custom Error Rendering
If you want to customize the rendering of the errors, you can access the errors using the errors slot prop and render them however you'd like.


<Field {form} name="name">
        <Control let:attrs>
                <Label>Name</Label>
                <input type="text" {...attrs} />
        </Control>
        <FieldErrors let:errors let:errorAttrs>
                {#each errors as err}
                        <span style="color: red;" {...errorAttrs}>{err}</span>
                {/each}
        </FieldErrors>
</Field>
Copy
Props
The FieldErrors component accepts all props that a standard HTML <div> element would accept along with a few additional props:


export type FieldErrorsProps = {
        /**
         * Optionally provide a unique id for the field errors container.
         * If not provided, a unique ID will be generated for you.
         */
        id?: string;
 
        /**
         * If `true`, Formsnap won't render the default `div` element
         * and will expect you to spread the `fieldErrorAttrs` slot prop into
         * a custom element/component of your choosing.
         *
         * @see https://formsnap.dev/docs/composition/aschild
         * @defaultValue `false`
         */
        asChild?: boolean;
 
        /**
         * You can bind to this prop to receive a reference to the
         * underling HTML element rendered for the validation message.
         */
        el?: HTMLDivElement;
} & HTMLAttributes<HTMLDivElement>;
Copy
Slot Props
The FieldErrors component provides three slot props, fieldErrorsAttrs, which is only necessary when using the asChild prop, errors, which is an array representing the errors for the field that the FieldErrors component is associated with, and errorAttrs, which are attributes that can (optionally) be spread onto each individual error element being rendered.


type SlotProps = {
        fieldErrorsAttrs: FieldErrorsAttrs;
        errorAttrs: ErrorAttrs;
        errors: string[];
};
Copy
Attributes
Field Errors Container
The following attributes are automatically applied to the container rendered by the FieldErrors component. This is also the shape of the fieldErrorsAttrs slot prop when using the asChild prop.


export type FieldErrorsAttrs = {
        /** The ID of the field error container element, used to describe the control. */
        id: string;
 
        /** Present when a validation error exists on the field. */
        "data-fs-error": string | undefined;
 
        /** Used for selection during styling or otherwise */
        "data-fs-field-errors": string;
 
        /** Notifies screen readers when a validation error occurs */
        "aria-live": "assertive" | "polite";
 
        /** Any additional props provided to `<Form.Validation />` */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        [key: string]: any;
};
Copy
Error Elements
The following attributes are automatically applied to the individual error elements rendered by the FieldErrors component. This is also the shape of the errorAttrs slot prop.


export type ErrorAttrs = {
        /** Used for selection during styling or otherwise */
        "data-fs-field-error": string;
 
        /** Present when a validation error exists on the field. */
        "data-fs-error": string | undefined;
};


Components


Control
Associates a label with and provides necessary attributes for a form control.


In the context of a form, a control refers to any interactive element such as an input field, a select dropdown, or a button. This includes custom components like select dropdowns or checkboxes that function as buttons but still serve as form inputs, typically activated by clicking on a label or pressing a key.


Each control and its label should be wrapped in its own Control component. This is important for accessibility, as it ensures that the label is associated with the control, and that the label is announced to screen readers when the control receives focus.


Why a separate component?
A common question is "why we can't just include this logic in the various Field components?".


Doing so would limit the Field component to a single control, which would prevent them from being used for checkbox groups, radio groups, and other multi-control components. The APIs are flexible enough that you could create your own custom wrapper components to make them more convenient to use for your specific use case.




Why a separate component?
Props
The Control component doesn't render an element itself, it strictly provides context and attributes for the control via a slot prop and state for the Label.


export type ControlProps = {
        /**
         * Optionally provide a unique id for the form item/control.
         * If not provided, a unique ID will be generated for you.
         *
         * This is useful when another library automatically generates
         * IDs for form items. You can pass that ID to the `id` prop and
         * the label will be associated with that control.
         */
        id?: string;
};
Copy
Slot Props
The only slot prop provided by the Control is the attrs prop which should be spread onto the control element/component.


Hey!
Don't forget to spread the attrs prop onto the control element/component. Forgetting to do so will result in the control not being associated with the label, which is a critical accessibility issue and will result in a poor user experience for everyone. Additionally, the control won't have the correct name attribute, which is necessary for form submission!




type SlotProps = {
        attrs: ControlAttrs;
};
Copy
Attributes
export type ControlAttrs = {
        /** The name of the control used for form submission. */
        name: string;
 
        /** The ID of the control, used for label association. */
        id: string;
 
        /** Present when a validation error exists on the field. */
        "data-fs-error": string | undefined;
 
        /** Present when description or validation exists. */
        "aria-describedby": string | undefined;
 
        /** Present when a validation error exists on the field. */
        "aria-invalid": "true" | undefined;
 
        /** Present when the field is required. */
        "aria-required": "true" | undefined;
 
        /** Used for selection during styling or otherwise */
        "data-fs-control": string;
};
Copy
Composition
Since the Control component doesn't render any HTML elements, it's a common practice to create a wrapper component around it to have consistent styling and behavior across your forms.


For example, you may want to automatically include the Label for each item, and you want the label and slot content to be wrapped in a <div>.


Here's how you might do just that:


CustomControl.svelte
<script lang="ts">
        import { Control, Label, type ControlProps } from "formsnap";
 
        type $$Props = ControlProps & {
                label: string;
        };
 
        export let label: string;
</script>
 
<Control let:attrs {...$$restProps}>
        <div class="flex flex-col gap-2">
                <Label>{label}</Label>
                <slot {attrs} />
        </div>
</Control>


Components


Label
Renders a label element for a control.


The Label component must be used as a child of a Control component. It renders a <label> element and includes the necessary attributes to associate it with the control.


Usage
When using a Label inside a Control, you don't need to worry about the for attribute. Formsnap handles that for you.


<Field {form} name="name">
        <Control let:attrs>
                <Label>Name</Label>
                <input type="text" {...attrs} />
        </Control>
</Field>
Copy
Props
A Label accepts all props that a standard HTML <label> element would accept along with a few additional props:


export type LabelProps = {
        /**
         * If `true`, Formsnap won't render the default `label` element
         * and will expect you to spread the `labelAttrs` slot prop into
         * a custom label element/component of your choosing.
         *
         * @see https://formsnap.dev/docs/composition/aschild
         * @defaultValue `false`
         */
        asChild?: boolean;
 
        /**
         * You can bind to this prop to receive a reference to the
         * underling HTML element rendered for the label.
         */
        el?: HTMLLabelElement;
} & HTMLLabelAttributes;
Copy
Slot Props
Label provides a single slot prop, labelAttrs, which is only necessary when using the asChild prop.


type SlotProps = {
        labelAttrs: LabelAttrs;
};
Copy
Attributes
The following attributes are automatically applied to the element rendered by the Label component. This is also the shape of the labelAttrs slot prop when using the asChild prop.


export type LabelAttrs = {
        /** The ID of the control, used for label association. */
        for: string;
 
        /** Present when a validation error exists on the field. */
        "data-fs-error": string | undefined;
 
        /** Used for selection during styling or otherwise */
        "data-fs-label": string;
 
        /** Any additional props provided to the `<Form.Label />` component */
        [key: string]: any;
};


Components


Description
Provides an accessible description for a form field.


The Description component provides an accessible description for a field. It renders a <div> element and should be used to provide additional context or instructions for a form field.


Descriptions must be used within the context of a Field, Fieldset, or ElementField component and will automatically be linked to the Control of the field using the aria-describedby attribute.


Usage
<Field name="name">
        <Control let:attrs>
                <Label>Name</Label>
                <input type="text" {...attrs} />
        </Control>
        <Description>
                Your full name, including your middle name if you have one.
        </Description>
</Field>
Copy
Props
The Description component accepts all props that a standard HTML <div> element would accept along with a few additional props:


export type DescriptionProps = {
        /**
         * Optionally provide a unique id for the description.
         * If not provided, a unique ID will be generated for you.
         */
        id?: string;
 
        /**
         * If true, Formsnap won't render the default `div` element and will
         * instead expect you to spread the `descriptionAttrs` slot prop into an
         * element of your choosing.
         *
         * @see https://formsnap.dev/docs/composition/aschild
         * @defaultValue `false`
         */
        asChild?: boolean;
 
        /**
         * You can bind to this prop to receive a reference to the
         * underling HTML element rendered for the description.
         */
        el?: HTMLDivElement;
} & HTMLAttributes<HTMLDivElement>;
Copy
Slot Props
The Description component provides a single slot prop, descriptionAttrs, which is only necessary when using the asChild prop.


type SlotProps = {
        descriptionAttrs: DescriptionAttrs;
};
Copy
Attributes
The following attributes are automatically applied to the element rendered by the Description component. This is also the shape of the descriptionAttrs slot prop when using the asChild prop.


export type DescriptionAttrs = {
        /** The ID of the description element, used to describe the control. */
        id: string;
 
        /** Used for selection during styling or otherwise */
        "data-fs-description": string;
 
        /** Present when a validation error exists on the field. */
        "data-fs-error": string | undefined;
 
        /* Any additional props provided to `<Form.Description />` */
        [key: string]: any;
};


Components


Legend
Provides a title for a group of related form controls.


You should always use the Legend component in conjunction with the Fieldset component to provide a title for a group of related form controls. See the the Fieldset component's documentation for more information on when to use a fieldset.


Props
The Legend component renders a <legend> element and accepts all props that a standard HTML <legend> element would accept along with a few additional props:


export type LegendProps = {
        /**
         * If `true`, Formsnap won't render the default `legend` element
         * and will expect you to spread the `legendAttrs` slot prop into
         * a custom legend element/component of your choosing.
         *
         * @see https://formsnap.dev/docs/composition/aschild
         * @defaultValue `false`
         */
        asChild?: boolean;
 
        /**
         * You can bind to this prop to receive a reference to the
         * underling HTML element rendered for the group title.
         */
        el?: HTMLLegendElement;
} & HTMLAttributes<HTMLLegendElement>;
Copy
Slot Props
The Legend component provides a single slot prop, legendAttrs, which is only necessary when using the asChild prop.


type SlotProps = {
        legendAttrs: LegendAttrs;
};
Copy
Attributes
The following attributes are automatically applied to the element rendered by the Legend component. This is also the shape of the legendAttrs slot prop when using the asChild prop.


export type LegendAttrs = {
        /** Used for selection during styling or otherwise */
        "data-fs-legend": string;
 
        /** Present when a validation error exists on the field. */
        "data-fs-error": string | undefined;
 
        /* Any additional props provided to `<Form.Legend />` */
        [key: string]: any;
};






COMPOSITION


Composition


asChild Prop
Use your own elements or components with Formsnap.


Although the provided components are the recommended and easiest way to use Formsnap, they aren't the only way. If you prefer to bring your own components or use native HTML elements, that's fine too.


The asChild prop is available on all components that render native HTML elements under the hood. When set to true, Formsnap won't render the default element and will expect you to spread the *Attrs slot prop into a custom element or component of your choosing.


Usage Example
If you wanted to use your own custom Label component or use scoped styles with a <label> element, you can do so by passing the asChild prop to the Label component.


<script lang="ts">
        import { Label } from "formsnap";
</script>
 
<Label asChild let:labelAttrs>
        <label {...labelAttrs} class="label">Name</label>
</Label>
 
<style>
        label {
                color: green;
        }
</style>
Copy
Tip
The documentation for each component will tell you which slot props are available and what attributes they contain.








Composition


getFormField
Use the form field's state for advanced composition with custom form components.


You can use getFormField within the context of a Field, Fieldset, or ElementField component to access the state of the field and use it to build more advanced form components.


Usage Example
The getFormField function is provided for more advanced use cases where you may need to access the entire state of a form field, as well as the form itself.


CustomFieldErrors.svelte
<script lang="ts">
        import { getFormField } from "formsnap";
        import { schema } from "./schema.js";
        import type { Infer } from "sveltekit-superforms";
        // whatever your validation library is
        import { z } from "zod";
 
        export let id: string;
 
        const { errors, fieldErrorsId } = getFormField<Infer<typeof schema>, "name">();
 
        $: fieldErrorsId.set(id);
</script>
 
{#if $errors.length > 0}
        <div class="error" {id}>
                {#each $errors as error}
                        <p>{error}</p>
                {/each}
        </div>
{/if}
Copy
API
The getFormField function returns an object with the following types:


import type { FormPath } from "sveltekit-superforms";
 
/**
 * State for the current form field.
 */
export type FormFieldContext<
        T extends Record<string, unknown>,
        U extends FormPath<T>,
> = {
        /** The original form object returned from the load function. */
        form: SuperForm<T>;
 
        /** A store containing the ID of the field errors container for the field. */
        fieldErrorsId: Writable<string>;
 
        /** A store containing the ID of the description element for the field. */
        descriptionId: Writable<string>;
 
        /** A store containing the name of the field. */
        name: Writable<U>;
 
        /** A store containing the current validations errors for the field. */
        errors: Writable<string[]>;
 
        /** A store containing the constraints (if any) for the field. */
        constraints: Writable<Record<string, unknown>>;
 
        /** A store containing the tainted state of the field. */
        tainted: Writable<boolean>;
};


Composition


getFormControl
Use the form control's state for more advanced composition.


You can use getFormControl within the context of a Control component to access the state of the control and use it as you see fit.


Usage
Say we're building a custom component that contains both a custom input and label.


LabelInput.svelte
<script lang="ts">
        import { getFormControl } from "formsnap";
        import CustomLabel from "$lib/components/CustomLabel.svelte";
        import CustomInput from "$lib/components/CustomInput.svelte";
 
        export let label: string;
 
        const { labelAttrs, attrs } = getFormControl();
</script>
 
<CustomLabel {...$labelAttrs}>
        {label}
</CustomLabel>
<CustomInput {...$attrs} />
Copy
In this example, we're using getFormControl to get the attributes for the label and control elements. We then pass those attributes to our custom components.


We'd then use this within the context of a Control component like so:


<Field {form} name="email">
        <Control>
                <LabelInput label="Email address" />
        </Control>
</Field>
Copy
API
The getFormControl function returns an object with the following types:


export type FormControlContext = {
        /** A store containing the ID of the form control. */
        id: Writable<string>;
 
        /** A store containing the attributes for the label element. */
        labelAttrs: Writable<LabelAttrs>;
 
        /** A store containing the attributes for the control element. */
        attrs: Writable<ControlAttrs>;
};

RECIPES


Recipes


Checkbox Groups
Learn how to build checkbox group inputs with Formsnap.


Checkbox groups are a set of checkboxes that allow users to select multiple options from a list, and are quite common in forms.


In this guide, you'll learn how to build a checkbox group with Formsnap by building an "Allergies" checkbox group, where a user must select any food allergies they have. We'll start with very basic functionality and then look at more advanced refinements for validation.


Create a Checkbox Group
For the purposes of this guide, we'll assume you're using the zod and zodClient adapters from Superforms, but the same principles apply to all adapters.


Define the Schema
Let's start by defining a schema that contains an array to hold the selected options. We'll create this inside the context="module" script tag of our Svelte component so we can access it in our component and +page.server.ts file.


+page.svelte
<script lang="ts" context="module">
        import { z } from "zod";
 
        const allergies = ["None", "Peanuts", "Shellfish", "Lactose", "Gluten"] as const;
 
        export const schema = z.object({
                allergies: z
                        .array(z.enum(allergies))
                        .min(1, "If you don't have any allergies, select 'None'."),
        });
</script>
Copy
We've defined an array named allergies that holds the possible enum values, and then created a schema that requires at least one option to be selected.


Setup the Load Function & Actions
Next, we'll create a +page.server.ts file where we'll define our load function and actions to handle the form submission.


+page.server.ts
import { superValidate } from "sveltekit-superforms";
import type { Actions, PageServerLoad } from "./$types";
import { schema } from "./+page.svelte";
import { zod } from "sveltekit-superforms/adapters";
import { fail } from "@sveltejs/kit";
 
export const load: PageServerLoad = async () => {
        return {
                form: await superValidate(zod(schema)),
        };
};
 
export const actions: Actions = {
        default: async (event) => {
                const form = await superValidate(event, zod(schema));
 
                if (!form.valid) {
                        return fail(400, { form });
                }
 
                return { form };
        },
};
Copy
Notice we're importing that schema we defined in our +page.svelte file and using it to validate the form data in the load function and actions.


Initialize the SuperForm
Now that we have our schema defined and our load function and actions set up, we can initialize the SuperForm in our Svelte component.


+page.svelte
<!-- script context="module" tag -->
 
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import { zodClient } from "sveltekit-superforms/adapters";
        import SuperDebug from "sveltekit-superforms";
 
        export let data;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
        const { form: formData, enhance } = form;
</script>
Copy
We're using the superForm function to initialize the form, passing in the form object from our load function and the zodClient adapter to handle client-side validation.


Import Components and Enhance the Form
Now that our SuperForm is initialized, we can use it to construct our checkbox group.


We'll first import the components we'll need from Formsnap, and then setup a form element with the enhance action to progressively enhance the form with client-side validation.


+page.svelte
<!-- script context="module" tag  -->
 
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import { zodClient } from "sveltekit-superforms/adapters";
        import SuperDebug from "sveltekit-superforms";
        import {
                Fieldset,
                Legend,
                Label,
                Control,
                FieldErrors,
                Description,
        } from "formsnap";
 
        export let data;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
        const { form: formData, enhance } = form;
</script>
 
<form method="POST" use:enhance>
        <!-- ... -->
        <button type="submit">Submit</button>
</form>
Copy
Construct the Fieldset
Since each checkbox in the group is related to a single field, we'll use a Fieldset component with a Legend to group them together. We'll use the Description component to provide more context about the fieldset and the FieldErrors component to display validation errors.


<!-- script tags -->
 
<form method="POST" use:enhance>
        <Fieldset {form} name="allergies">
                <Legend>Select your allergies</Legend>
                <!-- ... -->
                <Description>
                        We'll use this information to ensure your meals are safe.
                </Description>
                <FieldErrors />
        </Fieldset>
        <button type="submit">Submit</button>
</form>
Copy
Next, we'll iterate over the allergies array and create a Control that includes a Label and a checkbox input for each option.


<!-- script tags -->
 
<form method="POST" use:enhance>
        <Fieldset {form} name="allergies">
                <Legend>Select your allergies</Legend>
                {#each allergies as allergy}
                        <Control let:attrs>
                                <input
                                        type="checkbox"
                                        {...attrs}
                                        bind:group={$formData.allergies}
                                        value={allergy}
                                />
                                <Label>{value}</Label>
                        </Control>
                {/each}
                <Description>
                        We'll use this information to ensure your meals are safe.
                </Description>
                <FieldErrors />
        </Fieldset>
        <button type="submit">Submit</button>
</form>
Copy
Improve Validation
We now have a functional checkbox group that allows users to select multiple options from a list. However, we can make some improvements to enhance the user experience and provide better validation feedback.


You may have noticed that users can select "None" and another allergy at the same time, which doesn't make sense. We can address this by adding a refinement to our schema to ensure that if "None" is selected, no other allergies can be selected.


+page.svelte
<script lang="ts" context="module">
        import { z } from "zod";
 
        const allergies = ["None", "Peanuts", "Shellfish", "Lactose", "Gluten"] as const;
 
        export const schema = z.object({
                allergies: z
                        .array(z.enum(allergies))
                        .min(1, "If you don't have any allergies, select 'None'.")
                        .refine((v) => {
                                return v.includes("None") ? v.length === 1 : true;
                        }, "If you select 'None', you can't select any other allergies."),
        });
</script>
 
<!-- ...rest -->
Copy
We've added a refine method to the allergies array to ensure that if "None" is selected, no other allergies can be selected. If the user selects "None", the array length must be 1, otherwise the validation will fail and the custom error message will be displayed.


Finished Product
That's it! You've successfully created a checkbox group with Formsnap. With some custom styles and components applied, the finished product might look something like this:


Select any allergies you may have


None


Peanuts


Shellfish


Lactose


Gluten
We'll ensure to accommodate your dietary restrictions.
Submit
TLDR - Show Me the Code
For those who prefer to skip the guide and get straight to the code, here's the code required to create a checkbox group with Formsnap.


+page.server.ts
import { superValidate } from "sveltekit-superforms";
import type { Actions, PageServerLoad } from "./$types";
import { schema } from "./+page.svelte";
import { zod } from "sveltekit-superforms/adapters";
import { fail } from "@sveltejs/kit";
 
export const load: PageServerLoad = async () => {
        return {
                form: await superValidate(zod(schema)),
        };
};
 
export const actions: Actions = {
        default: async (event) => {
                const form = await superValidate(event, zod(schema));
 
                if (!form.valid) {
                        return fail(400, { form });
                }
 
                return { form };
        },
};
Copy
+page.svelte
<script lang="ts" context="module">
        import { z } from "zod";
 
        export const allergies = [
                "None",
                "Peanuts",
                "Shellfish",
                "Lactose",
                "Gluten",
        ] as const;
 
        export const schema = z.object({
                allergies: z
                        .array(z.enum(allergies))
                        .min(1, "If you don't have any allergies, select 'None'.")
                        .refine((v) => {
                                return v.includes("None") ? v.length === 1 : true;
                        }, "If you select 'None', you can't select any other allergies."),
        });
</script>
 
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import { zodClient } from "sveltekit-superforms/adapters";
 
        import {
                Fieldset,
                Legend,
                Label,
                Control,
                FieldErrors,
                Description,
        } from "formsnap";
 
        export let data;
 
        const form = superForm(data, {
                validators: zodClient(schema),
        });
        const { form: formData, enhance } = form;
</script>
 
<form method="POST" action="?/checkboxGroup" use:enhance>
        <Fieldset {form} name="allergies">
                <Legend>Select any allergies you may have</Legend>
                {#each allergies as allergy}
                        <Control let:attrs>
                                <input
                                        class="accent-brand"
                                        type="checkbox"
                                        {...attrs}
                                        bind:group={$formData.allergies}
                                        value={allergy}
                                />
                                <Label>{allergy}</Label>
                        </Control>
                {/each}
                <Description>We'll ensure to accommodate your dietary restrictions.</Description>
                <FieldErrors />
        </Fieldset>
        <button type="submit">Submit</button>
</form>


Recipes


Dynamic Fields
Learn how to creating dynamic fields by building a URLs field with Formsnap.


To create a dynamic field, you'll need to use the ElementField component, that allows you to treat each element of an array as it's own field.


In this recipe, we'll create a URLs field where users can add and remove URLs from their profile.


Create Dynamic Fields
Define the Schema
Here's the schema we'll use for the form we'll build in this guide. We'll assume you know how to setup the load function and actions in the +page.server.ts file.


schema.ts
import { z } from "zod";
 
export const schema = z.object({
        urls: z
                .array(z.string().url({ message: "Please enter a valid URL." }))
                .min(2, "You must include at least two URLs on your profile.")
                .default(["", ""]),
});
Copy
We've defined an array named urls that contains strings that must be valid URLs. We've also set a minimum length of 2 for the array itself, and provided two default values to start with. The minimum length of 2 may sounds strange, but we're only doing so to demonstrate different validation errors for the array and its elements.


Create the Form
We'll need to initialize our SuperForm with the form returned from the load function, and then setup the basic structure of our form.


+page.svelte
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import { zodClient } from "sveltekit-superforms/adapters";
        import { schema } from "./schema.js";
 
        export let data;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
 
        const { form: formData, enhance } = form;
</script>
 
<form use:enhance method="POST">
        <!-- ... -->
        <button type="submit">Submit</button>
</form>
Copy
Import the Components
We have a few components we need to import to build the form.


+page.svelte
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import { zodClient } from "sveltekit-superforms/adapters";
        import {
                Fieldset,
                Legend,
                ElementField,
                Control,
                Label,
                FieldErrors,
                Description,
        } from "formsnap";
        import { schema } from "./schema.js";
 
        export let data;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
 
        const { form: formData, enhance } = form;
</script>
 
<form use:enhance method="POST">
        <!-- ... -->
        <button type="submit">Submit</button>
</form>
Copy
Scaffold the Fieldset
Since our individual URL inputs will be part of the same field, we'll use a Fieldset component to group them together and a Legend to provide a title.


+page.svelte
<!-- script tag -->
<form use:enhance method="POST">
        <Fieldset {form} name="urls">
                <Legend>Public URLs</Legend>
                <!-- ... -->
                <Description>
                        Add URLs to your profile that you'd like to share with others.
                </Description>
                <FieldErrors />
        </Fieldset>
        <button type="submit">Submit</button>
</form>
Copy
The FieldErrors component will display any validation errors for the array itself. In our case, it will display an error if the array doesn't contain at least two URLs (we'll add the erros for the individual URLs in the next step).


The Description component will provide additional context about the fields once we've created them, but each field will share the same description from the Fieldset scope.


Render the URL Fields
Now that we've scaffolded the Fieldset, we can iterate over the $formData.urls array to render the individual URL fields, which are represented by the ElementField component.


+page.svelte
<!-- script tag -->
<form use:enhance method="POST">
        <Fieldset {form} name="urls">
                <Legend>Public URLs</Legend>
                {#each $formData.urls as _, i}
                        <ElementField {form} name="urls[{i}]">
                                <Control let:attrs>
                                        <Label class="sr-only">URL {i + 1}</Label>
                                        <input type="url" {...attrs} bind:value={$formData.urls[i]} />
                                </Control>
                                <Description class="sr-only">
                                        This URL will be publicly available on your profile.
                                </Description>
                                <FieldErrors />
                        </ElementField>
                {/each}
                <FieldErrors />
        </Fieldset>
        <button type="submit">Submit</button>
</form>
Copy
We're using the ElementField component to treat each element of the urls array as a separate field with its own state and validation. We're also using the Control component to create a label and input for each URL, and binding the input's value to the corresponding element of the urls array.


Tip
You should always include a label for each input for accessibility purposes. In this case, because we don't want to display a label visually for each input, we've added a class to the label to visually hide it while still making it available to screen readers.




Make the Fields Dynamic
At the moment, the user can only have two URLs in their profile. We want to allow them to add and remove URLs as needed. We can achieve this by adding buttons to add and remove URLs.


+page.svelte
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import { zodClient } from "sveltekit-superforms/adapters";
        import {
                Fieldset,
                Legend,
                ElementField,
                Control,
                Label,
                FieldErrors,
                Description,
        } from "formsnap";
        import { schema } from "./schema.js";
 
        export let data;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
 
        const { form: formData, enhance } = form;
 
        function removeUrlByIndex(index: number) {
                $formData.urls = $formData.urls.filter((_, i) => i !== index);
        }
 
        function addUrl() {
                $formData.urls = [...$formData.urls, ""];
        }
</script>
 
<form use:enhance method="POST">
        <Fieldset {form} name="urls">
                <Legend>Public URLs</Legend>
                {#each $formData.urls as _, i}
                        <ElementField {form} name="urls[{i}]">
                                <Control let:attrs>
                                        <Label class="sr-only">URL {i + 1}</Label>
                                        <input type="url" {...attrs} bind:value={$formData.urls[i]} />
                                        <button type="button" on:click={() => removeUrlByIndex(i)}>
                                                Remove URL
                                        </button>
                                </Control>
                                <Description class="sr-only">
                                        This URL will be publicly available on your profile.
                                </Description>
                                <FieldErrors />
                        </ElementField>
                {/each}
                <FieldErrors />
                <button type="button" on:click={addUrl}>Add URL</button>
        </Fieldset>
 
        <button type="submit">Submit</button>
</form>
Copy
We've added a removeUrlByIndex function that removes a URL from the urls array by its index, and a addUrl function that adds a new URL to the urls array. We've also added a button to remove each URL and a button to add a new URL.


Now the user can add and remove URLs as needed, and the form will validate the array and its elements according to the schema we defined.


Finished Product
That's it! 🎉


You've created a dynamic field that allows users to add and remove URLs from their profile. With some custom styles and finesse, you can make the form look something like this:


Public URLs


This URL will be displayed on your public profile.


This URL will be displayed on your public profile.
These URLs will be displayed on your public profile.
URL
Submit
TLDR - Show Me the Code
Here's the complete code for the form we built in this guide:


schema.ts
import { z } from "zod";
 
export const schema = z.object({
        urls: z
                .array(z.string().url({ message: "Please enter a valid URL." }))
                .min(2, "You must include at least two URLs on your profile.")
                .default(["", ""]),
});
Copy
+page.svelte
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import { zodClient } from "sveltekit-superforms/adapters";
        import {
                Fieldset,
                Legend,
                ElementField,
                Control,
                Label,
                FieldErrors,
                Description,
        } from "formsnap";
        import { schema } from "./schema.js";
 
        export let data;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
 
        const { form: formData, enhance } = form;
 
        function removeUrlByIndex(index: number) {
                $formData.urls = $formData.urls.filter((_, i) => i !== index);
        }
 
        function addUrl() {
                $formData.urls = [...$formData.urls, ""];
        }
</script>
 
<form use:enhance method="POST">
        <Fieldset {form} name="urls">
                <Legend>Public URLs</Legend>
                {#each $formData.urls as _, i}
                        <ElementField {form} name="urls[{i}]">
                                <Control let:attrs>
                                        <Label class="sr-only">URL {i + 1}</Label>
                                        <input type="url" {...attrs} bind:value={$formData.urls[i]} />
                                        <button type="button" on:click={() => removeUrlByIndex(i)}>
                                                Remove URL
                                        </button>
                                </Control>
                                <Description class="sr-only">
                                        This URL will be publicly available on your profile.
                                </Description>
                        </ElementField>
                {/each}
                <FieldErrors />
                <button type="button" on:click={addUrl}>Add URL</button>
        </Fieldset>
 
        <button type="submit">Submit</button>
</form>


Recipes


Multiple Select
Learn how to build multiple select inputs with Formsnap.


In the following guide, you'll learn how to setup and validate multiple select fields with Formsnap by building an Ice Cream order form.


Building a Multiple Select Form
Define the Schema
Here's the schema we'll use for the form we'll build in this guide. We're assuming you know how to setup the load function and actions, and have already created a +page.svelte and +page.server.ts file.


schema.ts
import { z } from "zod";
 
export const flavors = [
        "vanilla",
        "chocolate",
        "cookies and cream",
        "strawberry",
] as const;
 
export const toppings = [
        "sprinkles",
        "hot fudge",
        "whipped cream",
        "cherry",
] as const;
 
export const schema = z
        .object({
                scoops: z.number().min(1).default(1),
                flavors: z.array(z.enum(flavors)).min(1, "You must select at least one flavor."),
                toppings: z
                        .array(z.enum(toppings))
                        .max(2, "You can only select up to two toppings."),
        })
        .refine((data) => (data.flavors.length > data.scoops ? false : true), {
                message: "You can only select as many flavors as you have scoops.",
                path: ["flavors"],
        });
Copy
The schema represents an ice cream order form with a scoops field, a flavors field, and a toppings field. The flavors and toppings fields are arrays of enums, and we've added some custom validation to ensure the user can only select as many flavors as they have scoops. We've also set a minimum of 1 for the flavors field and a maximum of 2 for the toppings field.


Create the Form
Let's initialize our SuperForm with the form returned from the load function and setup the basic structure of our form. We'll also want to import the schema, flavors, and toppings from the schema file.


+page.svelte
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import { zodClient } from "sveltekit-superforms/adapters";
        import { schema, flavors, toppings } from "./schema.js";
 
        export let data;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
 
        const { form: formData, enhance } = form;
</script>
 
<form use:enhance method="POST">
        <!-- ... -->
        <button type="submit">Submit</button>
</form>
Copy
Import the Components
At a minimum we need to import the Field, Control, Label, and FieldErrors components from Formsnap.


+page.svelte
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import { zodClient } from "sveltekit-superforms/adapters";
        import { Field, Control, Label, FieldErrors } from "formsnap";
        import { schema } from "./schema.js";
 
        export let data;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
 
        const { form: formData, enhance } = form;
</script>
 
<form use:enhance method="POST">
        <!-- ... -->
        <button type="submit">Submit</button>
</form>
Copy
Create the Scoops Field
The first field we'll create is the scoops field, which will be a regular select input with a range of 1 to 5 scoops.


+page.svelte
<!-- script tag -->
<form use:enhance method="POST">
        <Field {form} name="scoops">
                <Control let:attrs>
                        <div class="flex flex-col items-start gap-1">
                                <Label>Number of scoops</Label>
                                <select {...attrs} bind:value={$formData.scoops}>
                                        {#each Array.from({ length: 5 }, (_, i) => i + 1) as num}
                                                <option value={num}>
                                                        {num === 1 ? `${num} Scoop` : `${num} Scoops`}
                                                </option>
                                        {/each}
                                </select>
                        </div>
                </Control>
                <FieldErrors />
        </Field>
        <button type="submit">Submit</button>
</form>
Copy
Create the Flavors Field
Next, let's create the flavors field. This field will be a multiple select input with the available flavors as options.


+page.svelte
<!-- script tag -->
<form use:enhance method="POST">
        <Field {form} name="scoops">
                <Control let:attrs>
                        <div class="flex flex-col items-start gap-1">
                                <Label>Number of scoops</Label>
                                <select {...attrs} bind:value={$formData.scoops}>
                                        {#each Array.from({ length: 5 }, (_, i) => i + 1) as num}
                                                <option value={num}>
                                                        {num === 1 ? `${num} Scoop` : `${num} Scoops`}
                                                </option>
                                        {/each}
                                </select>
                        </div>
                </Control>
                <FieldErrors />
        </Field>
        <Field {form} name="flavors">
                <Control let:attrs>
                        <div class="flex flex-col items-start gap-1">
                                <Label>What flavors do you fancy?</Label>
                                <select multiple bind:value={$formData.flavors} {...attrs}>
                                        {#each flavors as flavor}
                                                <option value={flavor} selected={$formData.flavors.includes(flavor)}>
                                                        {flavor}
                                                </option>
                                        {/each}
                                </select>
                        </div>
                </Control>
                <FieldErrors />
        </Field>
        <button type="submit">Submit</button>
</form>
Copy
Notice that we're using the multiple attribute on the select element to allow the user to select multiple options. We're also using the selected attribute to pre-select the options that are already in the formData.flavors array.


Create the Toppings Field
Finally, let's create the toppings field. This field will also be a multiple select input with the available toppings as options.


+page.svelte
<!-- script tag -->
<form use:enhance method="POST">
        <Field {form} name="scoops">
                <Control let:attrs>
                        <div class="flex flex-col items-start gap-1">
                                <Label>Number of scoops</Label>
                                <select {...attrs} bind:value={$formData.scoops}>
                                        {#each Array.from({ length: 5 }, (_, i) => i + 1) as num}
                                                <option value={num}>
                                                        {num === 1 ? `${num} Scoop` : `${num} Scoops`}
                                                </option>
                                        {/each}
                                </select>
                        </div>
                </Control>
                <FieldErrors />
        </Field>
        <Field {form} name="flavors">
                <Control let:attrs>
                        <div class="flex flex-col items-start gap-1">
                                <Label>What flavors do you fancy?</Label>
                                <select multiple bind:value={$formData.flavors} {...attrs}>
                                        {#each flavors as flavor}
                                                <option value={flavor} selected={$formData.flavors.includes(flavor)}>
                                                        {flavor}
                                                </option>
                                        {/each}
                                </select>
                        </div>
                </Control>
                <FieldErrors />
        </Field>
        <Field {form} name="toppings">
                <Control let:attrs>
                        <div class="flex flex-col items-start gap-1">
                                <Label>Select your toppings</Label>
                                <select multiple bind:value={$formData.toppings} {...attrs}>
                                        {#each toppings as topping}
                                                <option value={topping} selected={$formData.toppings.includes(topping)}>
                                                        {topping}
                                                </option>
                                        {/each}
                                </select>
                        </div>
                </Control>
                <FieldErrors />
        </Field>
        <button type="submit">Submit</button>
</form>
Copy
Finished Product
That's it! 🎉


You've created the functionality for a form containing multiple select inputs with validation. With some custom styles and finesse, you can make the form look something like this:


Number of scoops


1 Scoop
Select your flavors
vanillachocolatecookies and creamstrawberry
Only select one flavor per scoop.
Select your toppings
sprinkleshot fudgewhipped creamcherry
Submit


Recipes


Bits UI Select
How to use the Select component from Bits UI with Formsnap.


The Select component from Bits UI is a simple, yet powerful component for building a custom select menu. It powers the Select component for shadcn-svelte, which is one of the most popular UI projects for Svelte. This recipe will demonstrate how to integrate that component with Formsnap.


Single Select
We're going to build a "languages" select menu that allows the user to select a single language from a list of pre-defined options. We'll use a code to represent the language's value, and the language's name as the label.


Define the Schema
Here's the schema we'll use for the form we'll build in this guide. We'll assume you know how to setup the load function and actions in the +page.server.ts file.


schema.ts
import { z } from "zod";
 
export const languages = {
        en: "English",
        es: "Spanish",
        fr: "French",
        de: "German",
        it: "Italian",
        pt: "Portuguese",
        ru: "Russian",
        zh: "Chinese",
        ja: "Japanese",
        ko: "Korean",
} as const;
 
type Language = keyof typeof languages;
 
export const schema = z.object({
        language: z
                .enum(Object.keys(languages) as [Language, ...Language[]])
                .default("en"),
});
Copy
Setup the Form
+page.svelte
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import { zodClient } from "sveltekit-superforms/adapters";
        import { Select } from "bits-ui";
        import { Field, Control, Label, FieldErrors } from "formsnap";
 
        import { schema, languages } from "./schema.js";
 
        export let data;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
 
        const { form: formData, enhance } = form;
 
        $: selectedLanguage = {
                label: languages[$formData.language],
                value: $formData.language,
        };
</script>
 
<form method="POST" use:enhance>
        <Field {form} name="languages">
                <Control let:attrs>
                        <Label>Language</Label>
                        <Select.Root
                                selected={selectedLanguage}
                                onSelectedChange={(s) => {
                                        s && ($formData.language = s.value);
                                }}
                        >
                                <Select.Input name={attrs.name} />
                                <Select.Trigger {...attrs}>
                                        <Select.Value placeholder="Select a language" />
                                </Select.Trigger>
                                <Select.Content>
                                        {#each Object.entries(languages) as [value, label]}
                                                <Select.Item {value} {label} />
                                        {/each}
                                </Select.Content>
                        </Select.Root>
                </Control>
                <FieldErrors />
        </Field>
        <button type="submit">Submit</button>
</form>
Copy
We apply the attrs to the Select.Trigger component so that the label and other accessibility attributes are associated with it instead of the hidden Select.Input.


This enables the user to click the label to open the select menu, and also allows validation errors to automatically associate with the trigger element, which is the control in this case.


Warning
Only apply the name attribute to the Select.Input. Do not spread the entire attrs object onto it or you will have duplicate id attributes which creates invalid HTML and a mess of accessibility issues.




Finished Product
That's it! 🎉


With some additional styles and structure, the form could look something like this:


Language


English
The docs will be translated to your preferred language.
Submit
Multiple Select
The <Select /> component also supports multiple selection. Here's how you can use it to build a multi-select form.


Define the Schema
Here's the schema we'll use for the form we'll build in this guide. We'll assume you know how to setup the load function and actions in the +page.server.ts file.


schema.ts
import { z } from "zod";
 
export const colors = {
        blu: "Blue",
        red: "Red",
        grn: "Green",
        ylw: "Yellow",
        blk: "Black",
} as const;
 
type Color = keyof typeof colors;
 
export const schema = z.object({
        colors: z
                .array(z.enum(Object.keys(colors) as [Color, ...Color[]]))
                .min(1, "Please select at least one color."),
});
Copy
Setup the Form
+page.svelte
<script lang="ts">
        import { superForm } from "sveltekit-superforms";
        import { zodClient } from "sveltekit-superforms/adapters";
        import { Select } from "bits-ui";
        import { Field, Control, Label, FieldErrors } from "formsnap";
 
        import { schema, colors } from "./schema.js";
 
        export let data;
 
        const form = superForm(data.form, {
                validators: zodClient(schema),
        });
 
        const { form: formData, enhance } = form;
 
        $: selectedColors = $formData.colors.map((c) => ({ label: colors[c], value: c }));
</script>
 
<form method="POST" use:form.enhance class="flex flex-col gap-4">
        <Field {form} name="colors">
                <Control let:attrs>
                        <Label>Language</Label>
                        <Select.Root
                                multiple
                                selected={selectedColors}
                                onSelectedChange={(s) => {
                                        if (s) {
                                                $formData.colors = s.map((c) => c.value);
                                        } else {
                                                $formData.colors = [];
                                        }
                                }}
                        >
                                {#each $formData.colors as color}
                                        <input name={attrs.name} hidden value={color} />
                                {/each}
                                <Select.Trigger {...attrs}>
                                        <Select.Value placeholder="Select a language" />
                                </Select.Trigger>
                                <Select.Content>
                                        {#each Object.entries(colors) as [value, label]}
                                                <Select.Item {value} {label} />
                                        {/each}
                                </Select.Content>
                        </Select.Root>
                        <FieldErrors />
                </Control>
        </Field>
        <button type="submit">Submit</button>
</form>
Copy
Notice that we need to use a hidden input for each selected value in the multiple select. This enables SuperForms to properly track the values and validate them on the server.


Warning
Only apply the name attribute to the Select.Input. Do not spread the entire attrs object onto it or you will have duplicate id attributes which creates invalid HTML and a mess of accessibility issues.




Finished Product
That's it! 🎉


With some additional styles and structure, the form could look something like this:


Favorite colors


Select colors
We'll use these colors to customize your experience.
Submit